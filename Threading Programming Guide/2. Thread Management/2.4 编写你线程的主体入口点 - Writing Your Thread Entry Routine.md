## 2.4 编写你线程的主体入口点

### 2.4.1 创建一个自动释放池（Autorelease Pool）

在 Objective - C 框架链接的应用程序，通常在它们的每一个线程必须创建至少一个自动释放池。如果应用程序使用内存管理模型，即应用程序处理的 retain 和 release 对象，那么自动释放池捕获任何从该线程 autorelease 的对象。

如果应用程序使用的垃圾回收机制，而不是管理的内存模型，那么创建一个自动释放池不是绝对必要的。在垃圾回收的应用程序里面，一个自动释放池是无害的，而且大部分情况是被忽略。允许通过个代码管理必须同时支持垃圾回收和内存管理模型。在这种情况下，内存管理模型必须支持自动释放池，当应用程序运行垃圾回收的时候，自动释放池只是被忽略而已。

如果你的应用程序使用内存管理模型，在你编写线程主体入口的时候第一件事情就是创建一个自动释放池。同样，在你的线程最后应该销毁该自动释放池。该池保证自动释放。虽然对象被调用，但是它们不被 release 直到线程退出。列表 2-2 显示了线程主体入口使用自动释放池的基本结构。

Listing 2-2 Defining your thread entry point routine

``` Objective-C
- (void)myThreadMainRoutine
{
 NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; // Top-level pool
 // Do thread work here.
  [pool release]; // Release the objects in the pool.
}
```

因为高级的自动释放池不会释放它的对象直到线程退出。长时运行的线程需求新建额外的自动释放池来更频繁的释放它的对象。比如，一个使用 run loop 的线程可能在每次运行完一次循环的时候创建并释放该自动释放池。更频繁的释放对象可以防止你的应用程序内存占用太大造成性能问题。虽然对于任何与性能相关的行为，你应该测量你代码的实际表现，并适当地调整使用自动释放池。关于更多内存管理的信息和自动释放池，参阅“内存高级管理编程指南(Advanced Memory Management Programming Guide)”。

### 2.4.2 设置异常处理
如果你的应用程序捕获并处理异常，那么你的线程代码应该时刻准备捕获任何可能发生的异常。虽然最好的办法是在异常发生的地方捕获并处理它，但是如果在你的线程里面捕获一个抛出的异常失败的话有可能造成你的应用程序强退。在你线程的主体入口点安装一个 try/catch 模块，可以让你捕获任何未知的异常，并提供一个合适的响应。
当在 Xcode 构建你项目的时候，你可以使用 C++ 或者 Objective-C 的异常处理风格。 关于更多设置如何在 Objective-C 里面抛出和捕获异常的信息，参阅 ExceptionProgramming Topics。

### 2.4.3 设置一个 Run Loop
当你想编写一个独立运行的线程时，你有两种选择：
* 第一种选择是写代码作为一个长期的任务，很少甚至不中断，线程完成的时候退出。
* 第二种选择是把你的线程放入一个循环里面，让它动态的处理到来的任务请求。

第一种方法不需要在你的代码指定任何东西；你只需要启动的时候做你打算做的事情即可，然而第二种选择需要在你的线程里面添加一个 run loop。

Mac OS X 和 iOS 提供了在每个线程实现 run loop 内置支持。Cocoa、Carbon 和 UIKit 自动在你应用程序的主线程启动一个 run loop，但是如果你创建任何辅助线程，你必须手工的设置一个 run loop 并启动它。


