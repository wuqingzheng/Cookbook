## 2.3 配置线程属性

创建线程之后，或者有时候是之前，你可能需要配置不同的线程环境。以下部分描述了一些你可以做的改变，和在什么时候你需要做这些改变。

### 2.3.1 配置线程的堆栈大小

对于每个你新创建的线程，系统会在你的进程空间里面分配一定的内存作为该线程的堆栈。该堆栈管理堆栈帧，也是任何线程局部变量声明的地方。给线程分配的内存大小在“线程成本”里面已经列举了。

如果你想要改变一个给定线程的堆栈大小，你必须在创建该线程之前做一些操作。所有的线程技术提供了一些办法来设置线程堆栈的大小。虽然可以使用 NSThread 来设置堆栈大小，但是它只能在 iOS 和 Mac OS X v10.5 及其之后才可用。表 2-2 列出了每种技术的对于不同的操作。

### 2.3.2 配置线程本地存储

每个线程都维护了一个键-值的字典，它可以在线程里面的任何地方被访问。你可以使用该字典来保存一些信息，这些信息在整个线程的执行过程中都保持不变。比如，你可以使用它来存储在你的整个线程过程中 Run loop 里面多次迭代的状态信息。Cocoa 和 POSIX 以不同的方式保存线程的字典，所以你不能混淆并同时调用者两种技术。然而只要你在你的线程代码里面坚持使用了其中一种技术，最终的结果应该是一样的。在 Cocoa 里面，你使用 NSThread 的 threadDictionary 方法来检索一个NSMutableDictionary 对象，你可以在它里面添加任何线程需要的键。在 POSIX 里面，你使用pthread_setspecific和pthread_getspecific函数来设置和访问你线程的键和值。

### 2.3.3 设置线程的脱离状态

大部分上层的线程技术都默认创建了脱离线程（Datached thread）。大部分情况下，脱离线程(Detached thread)更受欢迎，因为它们允许系统在线程完成的时候立即释放它的数据结构。脱离线程同时不需要显示的和你的应用程序交互。意味着线程检索的结果由你来决定。相比之下，系统不回收可连接线程（Joinable thread）的资源直到另一个线程明确加入该线程，这个过程可能会阻止线程执行加入。

你可以认为可连接线程类似于子线程。虽然你作为独立线程运行，但是可连接线程在它资源可以被系统回收之前必须被其他线程连接。可连接线程同时提供了一个显示的方式来把数据从一个正在退出的线程传递到其他线程。在它退出之前，可连接线程可以传递一个数据指针或者其他返回值给 pthread_exit 函数。其他线程可以通过 pthread_join 函数来拿到这些数据。

重要：在应用程序退出时，脱离线程可以立即被中断，而可连接线程则不可以。每个可连接线程必须在进程被允许可以退出的时候被连接。所以当线程处于周期性工作而不允许被中断的时候，比如保存数据到硬盘，可连接线程是最佳选择。

如果你想要创建可连接线程，唯一的办法是使用 POSIX 线程。POSIX 默认创建的线程是可连接的。为了把线程标记为脱离的或可连接的，使用 pthread_attr_setdetachstate 函数来修改正在创建的线程的属性。在线程启动后，你可以通过调用 pthread_detach 函数来把线程修改为可连接的。关于更多 POSIX 线程函数信息，参与 pthread 主页。关于更多如果连接一个线程，参阅 pthread_join 的主页。

### 2.3.4 设置线程的优先级

你创建的任何线程默认的优先级是和你本身线程相同。内核调度算法在决定该运行那个线程时，把线程的优先级作为考量因素，较高优先级的线程会比较低优先级的线程具有更多的运行机会。较高优先级不保证你的线程具体执行的时间，只是相比较低优先级的线程，它更有可能被调度器选择执行而已。

重要：让你的线程处于默认优先级值是一个不错的选择。增加某些线程的优先级，同时有可能增加了某些较低优先级线程的饥饿程度。如果你的应用程序包含较高优先级和较低优先级线程，而且它们之间必须交互，那么较低优先级的饥饿状态有可能阻塞其他线程，并造成性能瓶颈。

如果你想改变线程的优先级，Cocoa 和 POSIX 都提供了一种方法来实现。对于 Cocoa 线程而言，你可以使用 NSThread 的 setThreadPriority:类方法来设置当前运行线程的优先级。对于 POSIX 线程，你可以使用 pthread_setschedparam 函数来实现。关于更多信息，参与 NSThread Class Reference 或 pthread_setschedparam 主页。