### 2.5 中断线程

退出一个线程推荐的方法是让它在它主体入口点正常退出。尽管 **Cocoa**、**POSIX** 和 **Multiprocessing Services** 提供了直接杀死线程的例程，但是使用这些例程是强烈不鼓励的。杀死一个线程阻止了线程本身的清理工作。线程分配的内存可能造成泄露，并且其他线程当前使用的资源可能没有被正确清理干净，之后造成潜在的问题。

如果你的应用程序需要在一个操作中间中断一个线程，你应该设计你的线程响应取消或退出的消息。对于长时运行的操作，这意味着周期性停止工作来检查该消息是否到来。如果该消息的确到来并要求线程退出，那么线程就有机会来执行任何清理和退出工作；否则，它返回继续工作和处理下一个数据块。

响应取消消息的一个方法是使用 **run loop** 的输入源来接收这些消息。列表 2-3 显示了该结构的类似代码在你的线程的主体入口里面是怎么样的（该示例显示了主循环部分，不包括设立一个自动释放池或配置实际的工作步骤）。该示例在 **run loop** 上面安装了一个自定义的输入源，它可以从其他线程接收消息。关于更多设置输入源的信息，参阅“配置 Run Loop 源”。执行工作的总和的一部分后，线程运行的 run loop 来查看是否有消息抵达输入源。如果没有，run loop 立即退出，并且循环继续处理下一个数据块。因为该处理器并没有直接的访问 exitNow 局部变量，退出条件是通过线程的字典来传输的。

Listing 2-3 Checking for an exit condition during a long job

``` Objective-C
- (void)threadMainRoutine
{
 BOOL moreWorkToDo = YES;
 BOOL exitNow = NO;
 NSRunLoop* runLoop = [NSRunLoop currentRunLoop];
 
 // Add the exitNow BOOL to the thread dictionary.
 NSMutableDictionary* threadDict = [[NSThread currentThread] threadDictionary];
 [threadDict setValue:[NSNumber numberWithBool:exitNow] forKey:@"ThreadShouldExitNow"];
 
 // Install an input source.
 [self myInstallCustomInputSource];
 while (moreWorkToDo && !exitNow)
 {
 // Do one chunk of a larger body of work here.
 // Change the value of the moreWorkToDo Boolean when done.
 // Run the run loop but timeout immediately if the input source isn't waiting to fire.
 [runLoop runUntilDate:[NSDate date]];
 
 // Check to see if an input source handler changed the exitNow value.
 exitNow = [[threadDict valueForKey:@"ThreadShouldExitNow"] boolValue];
 
 }
}
```