## 2.2 创建一个线程
创建一个 low-level 线程相对简单。在任何情况下，你都必须有一个函数或方法来充当线程的主入口点，并且你必须使用其中一个可用的线程例程来启动线程。以下部分显示了常用的线程技术的基本创建过程。使用这些技术创建的线程将继承默认的一组属性，由您使用的技术决定。有关如何配置线程的信息，请参阅配置线程属性。

### 2.2.1 使用 NSThread

通过 NSThread 类，有两个方法来创建线程:
* 使用 `detachNewThreadSelector:toTarget:withObject:` 类方法来生成一个新的线程。
* 创建一个新的 NSThread 对象，并调用它的 start 方法。（仅在 iOS 和 Mac OS X v10.5 及其之后才支持）

这两种创建线程的技术都在你的应用程序里面新建了一个独立的线程。一个独立的线程意味着当线程退出的时候线程的资源由系统自动回收。这也意味着你的代码以后不需要明确加入到线程中。因为
`detachNewThreadSelctor:toTarget:withObject:` 
方法在 Mac OS X 的任何版本都支持，所以在 Cocoa 应用里面使用多线程的地方经常可以发现它。为了生成一个新的线程，你只要简单的提供你想要使用为线程主体入口的方法的名称(被指定为一个selector)，和任何你想在启动时传递给线程的数据。下面的示例演示了这种方法的基本调用，通过使用当前对象的自定义方法来生成一个线程。
```[NSThread detachNewThreadSelector:@selector(myThreadMainMethod:) toTarget:self withObject:nil];```

在 **Mac OS X v10.5** 之前，你使用 NSThread 类来生成线程。虽然你可以获取一个 NSThread 对象并访问线程的属性，但你只能在线程运行之后在其内部做到这些。在 **Mac OS X v10.5** 支持创建一个 NSThread 对象，而无需立即生成一个相应的新线程（这些在 iOS 里面同样可用）。新版支持使得在线程启动之前获取并设置线程的很多属性成为可能。这也让用线程对象来引用正在运行的线程成为可能。


在 Mac OS X v10.5 及其之后初始化一个 NSThread 对象的简单方法是使用
```initWithTarget:selector:object:```
方法。该方法和
```detachNewThreadSelector:toTarget:withObject:```
方法来初始化一个新的 NSThread 实例需要相同的额外开销。然而它并没有启动一个线程。为了启动一个线程，你可以明确调用对象的 `start` 方法，如下面代码：

``` Objective-C
NSThread* myThread = [[NSThread alloc] initWithTarget:self
 selector:@selector(myThreadMainMethod:)
 object:nil];
[myThread start]; // Actually create the thread
```

Note: An alternative to using the initWithTarget:selector:object: method is to subclass NSThread and override its main method. You would use the overridden version of this method to implement your thread’s main entry point. For more information, see the subclassing notes in NSThread Class Reference.

如果你拥有一个 NSThread 对象，它的线程当前真正运行，你可以给该线程发送消息的唯一方法是在你应用程序里面的任何对象使用```performSelector:onThread:withObject:waitUntilDone:```
方法。在 **Mac OS X v10.5** 支持在多线程上面执行 **selectors**（而不是在主线程里面），并且它是实现线程间通信的便捷方法。你使用该技术时所发送的消息会被其他线程作为 run-loop 主体的一部分直接执行（当然这些意味着目标线程必须在它的 run loop 里面运行，参阅“ RunLoops”）。当你使用该方法来实现线程通信的时候，你可能仍然需要一个同步操作，但是这比在线程间设置通信端口简单多了。

注意:虽然在线程间的偶尔通信的时候使用该方法很好，但是你不能周期的或频繁的使用
```performSelector:onThread:withObject:waitUntilDone:```
来实现线程间的通信。关于线程间通信的可选方法，参阅“设置线程的脱离状态”部分。

### 2.2.2 使用 POSIX 的多线程

Mac OS X 和 iOS 提供基于 C 语言支持的使用 POSIX 线程 API 来创建线程的方法。该技术实际上可以被任何类型的应用程序使用（包括 Cocoa 和 Cocoa Touch 的应用程序），并且如果你当前真为多平台开发应用的话，该技术可能更加方便。你使用来创建线程的 POSIX 例程被调用的时候，使用 pthread_create 刚好足够。

列表 2-1 显示了两个使用 POSIX 来创建线程的自定义函数。`LaunchThread` 函数创建了一个新的线程，该线程的例程由 `PosixThreadMainRoutine` 函数来实现。因为 POSIX 创建的线程默认情况是可连接的(joinable),下面的例子改变线程的属性来创建一个独立的线程。把线程标记为独立的，当它退出的时候让系统有机会立即回收该线程的资源。

Listing 2-1 Creating a thread in C

``` C
#include <assert.h>
#include <pthread.h>
void* PosixThreadMainRoutine(void* data)
{
 // Do some work here.
 return NULL;
}

void LaunchThread()
{
 // Create the thread using POSIX routines.
 pthread_attr_t attr;
 pthread_t posixThreadID;
 int returnVal;
 returnVal = pthread_attr_init(&attr);
 assert(!returnVal);
 returnVal = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
 assert(!returnVal);
 int threadError = pthread_create(&posixThreadID, &attr, &PosixThreadMainRoutine,
NULL);
 returnVal = pthread_attr_destroy(&attr);
 assert(!returnVal);
 if (threadError != 0)
 {
 // Report an error.
 }
}
```

如果你把上面列表的代码添加到你任何一个源文件，并且调用 LaunchThread 函数，它将会在你的应用程序里面创建一个新的脱离线程。当然，新创建的线程使用该代码没有做任何有用的事情。线程将会加载并立即退出。为了让它更有兴趣，你需要添加代码到 PosixThreadMainRoutine 函数里面来做一些实际的工作。为了保证线程知道该干什么，你可以在创建的时候给线程传递一个数据的指针。把该指针作为 pthread_create 的最后一个参数。

为了在新建的线程里面和你应用程序的主线程通信，你需要建立一条和目标线程之间的稳定的通信路径。对于基于 C 语言的应用程序，有几种办法来实现线程间的通信，包括使用端口（ports），条件(conditions)和共享内存(shared memory)。对于长期存在的线程，你应该几乎总是成立某种线程间的通信机制，让你的应用程序的主线程有办法来检查线程的状态或在应用程序退出时干净地关闭它。

关于更多介绍 POSIX 线程函数的信息，参阅 pthread 的主页。

### 2.2.3 使用 NSObject 来生成一个线程

在 iOS 和 Mac OS X v10.5 及其之后，所有的对象都可能生成一个新的线程，并用它来执行它任意的方法。方法   
```performSelectorInBackground:withObject:```
新生成一个脱离的线程，使用指定的方法作为新线程的主体入口点。比如，如果你有一些对象（使用变量 myObj 来代表），并且这些对象拥有一个你想在后台运行的 doSomething的方法，你可以使用如下的代码来生成一个新的线程:
```[myObj performSelectorInBackground:@selector(doSomething) withObject:nil];```
调用该方法的效果和你在之前对象里面使用 NSThread 的
```detachNewThreadSelector:toTarget:withObject:```
传递 selector，object 作为参数的方法一样。新的线程将会被立即生成并运行，它使用默认的设置。在 selector内部，你必须配置线程就像你在任何线程里面一样。比如，你可能需要设置一个自动释放池（如果你没有使用垃圾回收机制），在你要使用它的时候配置线程的 run loop。

关于更是介绍如果配置线程的信息，参阅“配置线程属性”部分。

### 2.2.4 使用其他线程技术

尽管 POSIX 例程和 NSThread 类被推荐使用来创建低级线程，但是其他基于 C 语言的技术在 Mac OS X 上面同样可用。在这其中，唯一一个可以考虑使用的是多处理服务（Multiprocessing Services），它本身就是在 POSIX 线程上执行。多处理服务是专门为早期的 Mac OS 版本开发的，后来在 Mac OS X 里面的 Carbon 应用程序上面同样适用。如果你有代码真是有该技术，你可以继续使用它，尽管你应该把这些代码转化为 POSIX。该技术在 iOS 上面不可用。关于更多如何使用多处理服务的信息，参阅多处理服务编程指南（Multiprocessing Services Programming Guide）。

### 2.2.5 在 Cocoa 程序上面使用 POSIX 线程

尽管 NSThread 类是 Cocoa 应用程序里面创建多线程的主要接口，如果方便的话你可以任意使用 POSIX 线程带替代。例如，如果你的代码里面已经使用了它，而你又不想改写它的话，这时你可能需要使用 POSIX 多线程。如果你真打算在 Cocoa 程序里面使用 POSIX 线程，你应该了解如果在 Cocoa 和线程间交互，并遵循以下部分的一些指南。

* Cocoa 框架的保护
对于多线程的应用程序，Cocoa 框架使用锁和其他同步方式来保证代码的正确执行。为了保护这些锁造成在单线程里面性能的损失，Cocoa 直到应用程序使用NSThread 类生成它的第一个新的线程的时候才创建这些锁。如果你仅使用 POSIX 例程来生成新的线程，Cocoa 不会收到关于你的应用程序当前变为多线程的通知。当这些刚好发生的时候，涉及 Cocoa 框架的操作可能会破坏甚至让你的应用程序崩溃。

为了让 Cocoa 知道你正打算使用多线程，你所需要做的是使用 NSThread 类生成一个线程，并让它立即退出。你线程的主体入口点不需要做任何事情。只需要使用 NSThread 来生成一个线程就足够保证 Cocoa 框架所需的锁到位。如果你不确定 Cocoa 是否已经知道你的程序是多线程的，你可以使用 NSThread 的 isMultiThreaded 方法来检验一下。

* 混合 POSIX 和 Cocoa 的锁
在同一个应用程序里面混合使用 POSIX 和 Cocoa 的锁很安全。Cocoa 锁和条件对象基本上只是封装了 POSIX 的互斥体和条件。然而给定一个锁，你必须总是使用同样的接口来创建和操纵该锁。换言之，你不能使用 Cocoa 的 NSLock 对象来操纵一个你使用 pthread_mutex_init 函数生成的互斥体，反之亦然。