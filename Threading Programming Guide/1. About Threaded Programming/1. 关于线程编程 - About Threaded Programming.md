# 关于线程编程（About Threaded Programming）
## 1.1 什么是线程（What Are Threads?）
> a thread is a combination of the kernel-level and application-level data structures needed to manage the execution of code.
> The kernel-level structures coordinate the dispatching of events to the thread and the preemptive scheduling of the thread on one of the available cores. 
> The application-level structures include the call stack for storing function calls and the structures the application needs to manage and manipulate the thread’s attributes and state.

线程是在应用程序内部实现多个执行路径的相对轻量级的方式。从技术角度来看，线程就是一个管理代码执行所需的内核级（**kernel-level**）和应用级（**application-level**）数据结构的组合。

* 内核级结构协助调度事件到线程，并抢占式调度这个线程到一个可用的内核上。
* 应用级结构包括用于存储函数调用的调用堆栈和应用程序需要管理和操作的线程属性和状态的结构。

在应用程序中使用多线程有两个非常重要的潜在好处：

* 多个线程可以提高应用程序的感知响应。
* 多个线程可以提高应用程序在多核系统上的实时性能。

同时，在应用程序中使用多线程的潜在问题：

* 应用程序内拥有多个可执行路径，会给你的代码增加更多的复杂性。
* 每个线程需要和其他线程协调其行为，以防止它破坏应用程序的状态信息。因为应用程序内的多个线程共享内存空间，它们访问相同的数据结构。如果两个线程试图同时处理相同的数据结构，一个线程有可能覆盖另外线程的改动导致破坏该数据结构。
* 即使有适当的保护，你仍然要注意由于编译器的优化导致给你代码产生很微妙的（和不那么微妙）的 Bug。

## 1.2 线程术语（Threading Terminology）

在讨论线程及其支持技术之前，有必要定义一些基本术语：

* 线程(thread)用于指代独立执行的代码段。
* 进程(process)用于指代一个正在运行的可执行程序，它可以包含多个线程。 
* 任务(task)用于指代抽象的概念，表示需要执行工作。 

## 1.3 线程的替代方法（Alternatives to Threads）

因为线程是一个相对底层和复杂的方式来支持应用程序并发，很可能会遇到同步或定时问题。

多线程解决了如何在同一个进程内并发的执行多路代码路径的问题。但是引入多线程也会带来大量的开销，包括内存消耗和 CPU 占用。如果这些开销对于你的预期工作而言实在太大，或者有其他更容易实现的方法，我们应该考虑是否真的需要多线程或并发。

表 1-1 列举了多线程的替代方法。该表包含了多线程的替代技术(比如 operation objects 和 GCD)和如何更高效的使用单个线程。

Table 1-1 Alternative technologies to threads

Technology | Description
-|:-:
**Operation objects** | 在 OS X v10.5 中引入的 operation object 通常是在辅助线程上执行的任务的包装。该包装器隐藏了执行任务的线程管理方面，使您可以专注于任务本身。operation object 通常与 operation queue object 结合使用，operation queue object 实际上管理一个或多个线程上 operation object 的执行。有关如何使用 operation object 的更多信息，请参见 [Concurrency Programming Guide]()。
**Grand Central Dispatch (GCD)** | 在 Mac OS x v10.6 中引入的 Grand Central Dispatch 是线程的另一种替代方法，它使您可以专注于需要执行的任务，而不是线程管理。使用GCD，您可以定义要执行的任务并将其添加到工作队列中，该工作队列可以在适当的线程上处理任务的调度。工作队列考虑了可用核心的数量和当前负载，从而比使用线程更有效地执行任务。有关如何使用 GCD 和工作队列的信息，请参阅 [Concurrency Programming Guide]()。
**Idle-time notifications** | 对于相对较短且优先级非常低的任务，idle time notifications 使您可以在应用程序不那么忙时执行任务。Cocoa 使用 NSNotificationQueue 对象为 idle time notifications 提供支持。要请求 idle time notifications，请使用 NSPostWhenIdle 选项将通知发布到默认的 NSNotificationQueue 对象。队列会延迟通知对象的传递，直到 runloop 变得空闲为止。有关更多信息，请参见 [Notification Programming Topics]()。
**Asynchronous functions** | 系统接口包括许多异步函数，这些函数可以为您提供自动并发。这些 API 可以使用系统守护程序和进程，或者创建自定义线程来执行其任务并将结果返回给您。（实际的实现是无关紧要的，因为它与代码分开了。）在设计应用程序时，请寻找具有异步行为的函数并考虑使用它们，而不是在自定义线程上使用等效的同步函数。
**Timers** | 您可以在应用程序的主线程上使用计时器来执行周期性的任务，这些任务虽然琐碎而无法使用线程，但仍需要定期进行维护。有关计时器的信息，请参见 [Timer Sources]()。
**Separate processes** | 尽管比线程更重，但是在任务仅与应用程序有切线关系的情况下，创建单独的进程可能会很有用。如果任务需要大量内存或必须使用 root 特权执行，则可以使用进程。例如，当 32 位应用程序将结果显示给用户时，您可以使用64位服务器进程来计算大型数据集。

Warnning：使用 `fork` 函数启动单独的进程时，你必须总是在 `fork` 后面调用 `exec` 或者类似的函数。基于 **Core Foundation**、**Cocoa** 或者 **Core Data** 框架（无论显式还是隐式关联）的应用程序必须对 `exec` 函数进行后续调用，否则这些框架的行为可能会不正确。

## 1.4 线程支持(Threading Support)

**Mac OS** 和 **iOS** 提供了多种技术来在应用程序中创建线程。此外，这两个系统还为管理和同步这些线程上需要完成的工作提供支持。以下各节介绍了在 **Mac OS** 和 **iOS** 中使用线程时需要注意的一些关键技术。

### 1.4.1 线程包(Threading Packages)

底层实现机制是 Mach 线程，但是我们通常使用更方便的 POSIX API 或其衍生工具, 很少（甚至从不）在 Mach 层面上使用线程。 

Table 1-2 Thread technologies

Technology| Description
-|:-:
Cocoa threads|Cocoa 使用 NSThread 类实现线程。Cocoa 还在 NSObject 上提供了用于生成新线程和在已运行的线程上执行代码的方法。更多信息请参见 [Using NSThread]() 和 [Using NSObject to Spawn a Thread]()。
POSIX threads|POSIX 线程提供基于 C 的用于创建线程的接口。如果您不是在编写 Cocoa 应用程序，那么这是创建线程的最佳选择。POSIX 接口使用起来相对简单，并且为配置线程提供了足够的灵活性。更多信息请参见 [Using POSIX Threads]()。
Multiprocessing Services| Multiprocessing Services 是从旧版 Mac OS 过渡的应用程序使用的基于 C 的遗留接口。该技术仅在 Mac OS X 中可用，任何新开发都应避免使用。 相反，您应该使用 NSThread 类或 POSIX 线程。如果您需要有关此技术的更多信息，请参阅 [Multiprocessing Services Programming Guide]()。

线程启动之后，线程就进入三个状态中的任何一个:运行(running)、就绪(ready)、阻塞(blocked), 线程持续在这三个状态之间切换，直到它最终退出或者进入中断状态。

我们创建一个新的线程，必须指定该线程的入口函数（入口函数由你想要在该线程上面执行的代码组成）。但函数返回或你主动中断线程的时候，线程永久停止且被系统回收。因为创建线程需要的内存和时间消耗都比较大，所以建议你的入口点函数做相当数量的工作，或建立一个 runloop 允许进行经常性的工作。

### 1.4.2 Run Loops

run loop 是用来在线程上管理事件异步到达的基础设施。一个 run loop 为线程监测一个或多个事件源。当事件到达的时候，系统唤醒线程并调度事件到 run loop,然后分配给指定程序。如果没有事件出现和准备处理，run loop 把线程置于休眠状态。

你创建线程的时候不需要使用一个 run loop，但是如果你这么做的话可以给用户带来更好的体验。Run Loops 可以让你使用最小的资源来创建长时间运行线程。因为 run loop 在没有任何事件处理的时候会把它的线程置于休眠状态，它消除了 CPU 周期轮询消耗，并防止处理器本身进入休眠状态并节省电源。

为了配置 run loop,你所需要做的是启动你的线程，获取 run loop 的对象引用，设置你的事件处理程序，并告诉 run loop 运行。Cocoa 和 Carbon 提供的基础设施会自动为你的主线程配置相应的 run loop。如果你打算创建长时间运行的辅助线程，那么你必须为你的线程配置相应的 run loop。

### 1.4.3 同步工具(Synchronization Tools)

如果多个线程在同一个时间试图使用或者修改同一个资源，就会出现问题。缓解该资源争夺的方法之一是消除共享资源，并确保每个线程都有在它操作的资源上面的独特设置。因为保持完全独立的资源是不可行的，所以你可能必须使用锁，条件，原子操作和其他技术来同步资源的访问。

锁提供了一次只有一个线程可以执行代码的有效保护形式。最普遍的一种锁是互斥锁，也就是我们通常所说的 "mutex"。当一个线程试图获取一个当前已经被其他线程占据的互斥锁的时候，它就会被阻塞直到其他线程释放该互斥锁。系统的几个框架提供了对互斥锁的支持，虽然它们都是基于相同的底层技术。此外 Cocoa 提供了几个互斥锁的变种来支持不同的行为类型，比如递归等。

除了锁，系统还提供了条件，确保在你的应用程序任务执行的适当顺序。条件作为一个看门人，阻塞给定的线程，直到它代表的条件变为真。当发生这种情况的时候，条件释放该线程并允许它继续执行。POSIX 级别和基础框架都直接提供了条件的支持。（如果使用**operation objects**，可以配置你的**operation objects**之间的依赖关系的顺序来确定任务的执行顺序，这和条件提供的行为非常相似）。

尽管锁和条件在并发设计中使用非常普遍，原子操作也是另外一种保护和同步访问数据的方法。原子操作可以对标量数据类型执行数学或逻辑运算的时候提供了替代锁的轻量级的方法。原子操作使用特殊的硬件指令来确保在其他线程有机会访问变量之前完成对变量的修改。

### 1.4.4 线程间通信(Inter-thread Communication)

虽然一个良好的设计会最大限度地减少所需的通信量，但在某些时候，线程之间的通信显得十分必要。线程可能需要处理新的工作要求，或向你应用程序的主线程报告其进度情况。在这些情况下，你需要一个方式来从其他线程获取信息。幸运的是线程共享相同的进程空间，这意味着你可以有多种选择来进行通信。

线程间通信有很多种方法，每种都有它的优点和缺点。“配置线程局部存储” 列出了很多你可以在 Mac OS 上面使用的通信机制。（异常的消息队列和 Cocoa 分布式对象，这些技术也可在 iOS 用来通信）。本表中的技术是按照复杂性的顺序列出。

Table 1-3 Communication mechanisms

Mechanism | Description
-|:-:
Direct messaging | Cocoa 应用程序支持直接在其他线程上执行 selector 的功能。这种能力意味着一个线程可以在任何其他线程上执行方法。因为它们是在目标线程的上下文中执行的，所以以此方式发送的消息将在该线程上自动序列化。有关输入源的信息，请参见 [Cocoa Perform Selector Sources]()。
Global variables, shared memory, and objects | 在两个线程之间传递信息的另一种简单方法是使用全局变量、共享对象或共享内存块。尽管共享变量既快速又简单，但它们也比直接传递消息更脆弱。必须使用锁或其他同步机制仔细保护共享变量，以确保代码的正确性。否则可能会导致条件竞争、数据损坏或崩溃。
Conditions | 条件是一种同步工具，可用于控制线程何时执行代码的特定部分。您可以将条件视为看门人，让线程仅在满足指定条件时才运行。有关如何使用条件的信息，请参阅 [Using Conditions]()。
Run loop sources | 自定义 runloop source 是您在线程上设置为接收特定于应用程序消息的源。 由于 runloop source 是事件驱动的，因此在无事可做时，线程会自动进入休眠状态，从而提高了线程的效率。有关 runloop 和 runloop source 的信息，请参阅 [Run Loops]()。
Ports and sockets| 基于端口的通信是在两个线程之间进行通信的一种更为复杂的方法，但它也是一种非常可靠的技术。更重要的是，端口和套接字可用于与外部实体（例如其他进程和服务）进行通信。为了提高效率，使用 runloop sources 实现端口，因此当端口上没有数据等待时，线程将进入休眠状态。有关 runloop 和基于端口的输入源的信息，请参阅 [Run Loops]()。
Message queues| 传统的 Multiprocessing Services 定义了先进先出（FIFO）队列，用于抽象管理输入和输出数据。尽管消息队列既简单又方便，但是它们却不如其他一些通信技术有效。有关如何使用消息队列的更多信息，请参见 [Multiprocessing Services Programming Guide]()。
Cocoa distributed objects | Distributed objects 是一种 Cocoa 技术，可提供基于端口的通信的高级实现。尽管可以将这种技术用于线程间通信，但是强烈建议不要这样做，因为它会产生大量开销。分布式对象更适合与其他进程进行通信，在这些进程之间进行事务的开销已经很高。有关更多信息，请参见 [Distributed Objects Programming Topics]()。.

## 1.5 设计技巧(Design Tips)

以下各节为帮助你实现自己的线程提供了指导，以确保代码的正确性。部分指南同时提供如何利用你的线程代码获得更好的性能。你应该在更改代码之前、期间、之后总是收集相关的性能统计数据。

### 1.5.1 避免显式创建线程（Avoid Creating Threads Explicitly）

手动编写创建线程代码不仅乏味而且容易出错，你应该尽可能避免这样做。Mac OS X 和 iOS 通过其他 API 接口提供了隐式的并发支持。你可以考虑使用 **asynchronous APIs**、**GCD** 或者 **operation objects** 来实现并发，而不是自己创建一个线程。这些技术背后为你做了线程相关的工作，并保证是无误的。此外，比如 **GCD** 和 **operation objects** 技术被设计用来管理线程，比通过自己的代码根据当前的负载调整活动线程的数量更高效。关于更多 **GCD** 和 **operation objects** 的信息，你可以查阅[Concurrency ProgrammingGuid](https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091)。

### 1.5.2 保持你的线程合理的忙（Keep Your Threads Reasonably Busy）

如果你准备手动创建和管理线程，请记住多线程消耗系统宝贵的资源。你应该尽力确保任何分配到线程的任务是运行相当长时间和富有成效的。同时你不应该害怕中断那些消耗大量空闲时间的线程。线程占用一定量的内存，其中一些是有限的，所以释放空闲线程不但帮助你减少了应用程序的内存占用，而且还能释放出更多的物理内存给其他系统进程使用。

重要:在你中断你的空闲线程开始之前，你必须总是记录你应用程序当前的性能基线测量。当你尝试修改后，采取额外的测量来确保你的修改实际上提高了性能，而不是对它操作损害。 

### 1.5.3 避免共享数据结构(Avoid Shared Data Structures)

避免造成线程相关资源冲突的最简单最容易的办法是给你应用程序的每个线程一份它需求的数据的副本。当最小化线程之间的通信和资源争夺时并行代码的效果最好。

即使你非常小心，创建多线程的应用也是很困难的。即使在你的代码里面所有正确的地方锁住共享资源，你的代码依然可能语义不安全的。比如，当在一个特定的顺序里面修改共享数据结构的时候，你的代码有可能遇到问题。以原子方式修改你的代码，来弥补可能随后对多线程性能产生损耗的情况。把避免资源争夺放在首位通常可以得到设计简单同样具有高性能的效果。

### 1.5.4 线程和你的用户界面(Threads and Your User Interface)

如果你的应用程序具有一个图形用户界面，建议你在主线程里面接收和界面相关的事件和初始化更新你的界面。这种方法有助于避免与处理用户事件和窗口绘图相关的同步问题。一些框架，比如 Cocoa，通常需要这样操作，但是它的事件处理可以不这样做，在主线程上保持这种行为的优势在于简化了管理你应用程序用户界面的逻辑。

有几个显著的例外，它有利于在其他线程执行图形操作。比如，QuickTime API 包含了一系列可以在辅助线程执行的操作，包括打开、渲染和压缩视频文件，以及导入导出图像。类似的，在 Carbon 和 Cocoa 里面，你可以使用辅助线程来创建、处理图片以及其他图片相关的计算。使用辅助线程来执行这些操作可以极大提高性能。如果你不确定一个操作是否和图像处理相关，那么你应该在主线程执行这些操作。

关于 QuickTime 线程安全的信息，查阅 Technical Note TN2125:“QuickTime 的线程安全编程”。关于 Cocoa 线程安全的更多信息，查阅“线程安全总结”。关于 Cocoa 绘画信息，查阅 Cocoa 绘画指南（Cocoa Drawing Guide）。

### 1.5.5 了解线程退出时的行为(Be Aware of Thread Behaviors at Quit Time)

进程一直运行直到所有非独立线程都已经退出为止。默认情况下，只有应用程序的主线程是以非独立的方式创建的，但是你也可以使用同样的方法来创建其他线程。当用户退出程序的时候，通常考虑适当的立即中断所有独立线程，因为通常独立线程所做的工作都是是可选的。如果你的应用程序使用后台线程来保存数据到硬盘或者做其他周期行的工作，那么你可能想把这些线程创建为非独立的来保证程序退出的时候不丢失数据。

以非独立的方式创建线程（又称作为可连接的）你需要做一些额外的工作。因为大部分上层线程封装技术默认情况下并没有提供创建可连接的线程，你必须使用POSIX API 来创建你想要的线程。此外，你必须在你的主线程添加代码，来当它们最终退出的时候连接非独立的线程。更多有关创建可连接的线程信息，请查阅“设置线程的脱离状态”部分。

如果你正在编程 Cocoa 的程序，你也可以通过使用 `applicationShouldTerminate:` 的代理方法来延迟程序的中断直到一段时间后或者完成取消。当延迟中断的时候，你的程序需要等待直到任何周期线程已经完成它们的任务且调用了 `replyToApplicationShouldTerminate:` 方法。关于更多这些方法的信息，请查阅 NSApplication Class Reference。

###  1.5.6 处理异常(Handle Exceptions)

当抛出一个异常时，异常的处理机制依赖于当前调用堆栈执行任何必要的清理。因为每个线程都有它自己的调用堆栈，所以每个线程都负责捕获它自己的异常。如果在辅助线程里面捕获一个抛出的异常失败，那么你的主线程也同样捕获该异常失败：它所属的进程就会中断。你无法捕获同一个进程里面其他线程抛出的异常。

如果你需要通知另一个线程（比如主线程）当前线程中的一个特殊情况，你应该捕捉异常，并简单地将消息发送到其他线程告知发生了什么事。根据你的模型和你正在尝试做的事情，引发异常的线程可以继续执行（如果可能的话）、等待指示或者干脆退出。

注意:在 Cocoa 里面，一个 NSException 对象是一个自包含对象，一旦它被引发了，那么它可以从一个线程传递到另外一个线程。

在一些情况下，异常处理可能是自动创建的。比如，Objective-C 中的 @synchronized 包含了一个隐式的异常处理。

### 1.5.7 干净地中断你的线程(Terminate Your Threads Cleanly)

线程自然退出的最好方式是让它达到其主入口结束点。虽然有不少函数可以用来立即中断线程，但是这些函数应仅用于作为最后的手段。在线程达到它自然结束点之前中断一个线程会阻碍该线程自己完成清理。如果线程已经分配了内存、打开了文件或者获取了其他类型资源，你的代码可能没办法回收这些资源，造成内存泄漏或者其他潜在的问题。

### 1.5.8 线程安全的库(Thread Safety in Libraries)

虽然应用程序开发人员控制应用程序是否执行多个线程，类库的开发者则无法这样控制。当开发类库时，你必须假设调用应用程序是多线程，或者多线程之间可以随时切换。因此你应该总是在你的临界区使用锁功能。

对类库开发者而言，只当应用程序是多线程的时候才创建锁是不明智的。如果你需要锁定你代码中的某些部分，早期应该创建锁对象给你的类库使用，更好是显式调用初始化类库。虽然你也可以使用静态库的初始化函数来创建这些锁，但是仅当没有其他方式的才应该这样做。执行初始化函数需要延长加载你类库的时间，且可能对你程序性能造成不利影响。

注意：永远记住在你的类库里面保持锁和释放锁的操作平衡。你应该总是记住锁定类库的数据结构，而不是依赖调用的代码提供线程安全环境。

如果你真正开发 Cocoa 的类库，那么当你想在应用程序变成多线程的时候收到通知的话，你可以给 `NSWillBecomeMultiThreadedNotification` 注册一个观察者。不过你不应用依赖于这些收到的通知，因为它们可能在你的类库被调用之前已经被发出了。

