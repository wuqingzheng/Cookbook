## 1.4 线程支持(Threading Support)

如果您现有的代码使用线程，则OS X和iOS提供了多种技术来在您的应用程序中创建线程。此外，这两个系统还为管理和同步这些线程上需要完成的工作提供支持。 以下各节介绍了在OS X和iOS中使用线程时需要注意的一些关键技术。


### 1.4.1 线程包(Threading Packages)

虽然线程的底层实现机制是 Mach 线程，但您很少（甚至从不）在Mach层面上使用线程。 相反，您通常使用更方便的 POSIX API 或其衍生工具。 Mach 实现所有线程的基本特征，包括抢先执行模型和调度线程的能力，因此它们彼此独立。

列表 1-2 列举你可以在你的应用程序使用的线程技术。

Table 1-2 Thread technologies

Technology| Description
-|:-:|-
Cocoa threads|Cocoa implements threads using the NSThread class. Cocoa also provides methods on NSObject for spawning new threads and executing code on already-running threads. For more information, see “Using NSThread” and “Using NSObject to Spawn a Thread.”
POSIX threads|POSIX threads provide a C-based interface for creating threads. If you are not writing a Cocoa application, this is the best choice for creating threads. The POSIX interface is relatively simple to use and offers ample flexibility for configuring your threads. For more information, see “Using POSIX Threads”
Multiprocessing Services| Multiprocessing Services is a legacy C-based interface used by applications transitioning from older versions of Mac OS. This technology is available in Mac OS X only and should be avoided for any new development. Instead, you should use the NSThread class or POSIX threads. If you need more information on this technology, see Multiprocessing Services Programming Guide.

在应用层上，和其他平台一样所有线程的行为本质上是相同的。线程启动之后，线程就进入三个状态中的任何一个:运行(running)、就绪(ready)、阻塞(blocked)。如果一个线程当前没有运行，那么它不是处于阻塞，就是等待外部输入，或者已经准备就绪等待分配 CPU。线程持续在这三个状态之间切换，直到它最终退出或者进入中断状态。

当你创建一个新的线程，你必须指定该线程的入口点函数（或者在 Cocoa 线程时候为入口点方法）。该入口点函数由你想要在该线程上面执行的代码组成。但函数返回的时候，或你显式的中断线程的时候，线程永久停止，且被系统回收。因为线程创建需要的内存和时间消耗都比较大，因此建议你的入口点函数做相当数量的工作，或建立一个运行循环允许进行经常性的工作。

为了获取更多关于线程支持的可用技术并且如何使用它们，请阅读“线程管理部分”。

### 1.4.2 Run Loops

注:为了便于记忆，文本后面部分翻译 Run Loops 的时候基本采用原义，而非翻译为“运行循环”。

一个 run loop 是用来在线程上管理事件异步到达的基础设施。一个 run loop 为线程监测一个或多个事件源。当事件到达的时候，系统唤醒线程并调度事件到 run loop,然后分配给指定程序。如果没有事件出现和准备处理，run loop 把线程置于休眠状态。

你创建线程的时候不需要使用一个 run loop，但是如果你这么做的话可以给用户带来更好的体验。Run Loops 可以让你使用最小的资源来创建长时间运行线程。因为 run loop 在没有任何事件处理的时候会把它的线程置于休眠状态，它消除了消耗 CPU 周期轮询，并防止处理器本身进入休眠状态并节省电源。

为了配置 run loop,你所需要做的是启动你的线程，获取 run loop 的对象引用，设置你的事件处理程序，并告诉 run loop 运行。Cocoa 和 Carbon 提供的基础设施会自动为你的主线程配置相应的 run loop。如果你打算创建长时间运行的辅助线程，那么你必须为你的线程配置相应的 run loop。

关于 run loops 的详细信息和如何使用它们的例子会在“Run Loops”部分介绍。

### 1.4.3 同步工具(Synchronization Tools)

线程编程的危害之一是在多个线程之间的资源争夺。如果多个线程在同一个时间试图使用或者修改同一个资源，就会出现问题。缓解该问题的方法之一是消除共享资源，并确保每个线程都有在它操作的资源上面的独特设置。因为保持完全独立的资源是不可行的，所以你可能必须使用锁，条件，原子操作和其他技术来同步资源的访问。

锁提供了一次只有一个线程可以执行代码的有效保护形式。最普遍的一种锁是互斥排他锁，也就是我们通常所说的“mutex”。当一个线程试图获取一个当前已经被其他线程占据的互斥锁的时候，它就会被阻塞直到其他线程释放该互斥锁。系统的几个框架提供了对互斥锁的支持，虽然它们都是基于相同的底层技术。此外 Cocoa 提供了几个互斥锁的变种来支持不同的行为类型，比如递归。获取更多关于锁的种类的信息，请阅读“锁”部分内容。

除了锁，系统还提供了条件，确保在你的应用程序任务执行的适当顺序。一个条件作为一个看门人，阻塞给定的线程，直到它代表的条件变为真。当发生这种情况的时候，条件释放该线程并允许它继续执行。POSIX 级别和基础框架都直接提供了条件的支持。（如果你使用操作对象，你可以配置你的操作对象之间的依赖关系的顺序确定任务的执行顺序，这和条件提供的行为非常相似）。

尽管锁和条件在并发设计中使用非常普遍，原子操作也是另外一种保护和同步访问数据的方法。原子操作在以下情况的时候提供了替代锁的轻量级的方法，其中你可以执行标量数据类型的数学或逻辑运算。原子操作使用特殊的硬件设施来保证变量的改变在其他线程可以访问之前完成。

获取更多关于可用同步工具信息，请阅读“同步工具”部分。

### 1.4.4 线程间通信(Inter-thread Communication)

虽然一个良好的设计最大限度地减少所需的通信量，但在某些时候，线程之间的通信显得十分必要。（线程的任务是为你的应用程序工作，但如果从来没有使用过这些工作的结果，那有什么好处呢？）线程可能需要处理新的工作要求，或向你应用程序的主线程报告其进度情况。在这些情况下，你需要一个方式来从其他线程获取信息。幸运的是，线程共享相同的进程空间，意味着你可以有大量的可选项来进行通信。

线程间通信有很多种方法，每种都有它的优点和缺点。“配置线程局部存储”列出了很多你可以在 Mac OS X 上面使用的通信机制。（异常的消息队列和 Cocoa 分布式对象，这些技术也可在 iOS 用来通信）。本表中的技术是按照复杂性的顺序列出。

Table 1-3 Communication mechanisms

Mechanism | Description
-|:-:
Direct messaging|Cocoa applications support the ability to perform selectors directly on other threads. This capability means that one thread can essentially execute a method on any other thread. Because they are executed in the context of the target thread, messages sent this way are automatically serialized on that thread. For information about input sources, see “Cocoa Perform Selector Sources.”
Global variables, shared memory, and objects|Another simple way to communicate information between two threads is to use a global variable, shared object, or shared block of memory. Although shared variables are fast and simple, they are also more fragile than direct messaging. Shared variables must be carefully protected with locks or other synchronization mechanisms to ensure the correctness of your code. Failure to do so could lead to race conditions, corrupted data, or crashes.
Conditions | Conditions are a synchronization tool that you can use to control when a thread executes a particular portion of code. You can think of conditions as gate keepers, letting a thread run only when the stated condition is met. For information on how to use conditions, see “Using Conditions.”
Run loop sources| A custom run loop source is one that you set up to receive application-specific messages on a thread. Because they are event driven, run loop sources put your thread to sleep automatically when there is nothing to do, which improves your thread’s efficiency. For information about run loops and run loop sources, see “Run Loops.”
Ports and sockets| Port-based communication is a more elaborate way to communication between two threads, but it is also a very reliable technique. More importantly, ports and sockets can be used to communicate with external entities, such as other processes and services. For efficiency, ports are implemented using run loop sources, so your thread sleeps when there is no data waiting on the port. For information about run loops and about port-based input sources, see “Run Loops.”
Message queues| The legacy Multiprocessing Services defines a first-in, first-out (FIFO) queue abstraction for managing incoming and outgoing data. Although message queues are simple and convenient, they are not as efficient as some other communications techniques. For more information about how to use message queues, see Multiprocessing Services Programming Guide.
Cocoa distributed objects| Distributed objects is a Cocoa technology that provides a high-level implementation of port-based communications. Although it is possible to use this technology for inter-thread communication, doing so is highly discouraged because of the amount of overhead it incurs. Distributed objects is much more suitable for communicating with other processes, where the overhead of going between processes is already high. For more information, seeDistributed Objects Programming Topics.