# 关于线程编程（About Threaded Programming）
## 1.1 什么是线程（What Are Threads?）
> a thread is a combination of the kernel-level and application-level data structures needed to manage the execution of code.
> The kernel-level structures coordinate the dispatching of events to the thread and the preemptive scheduling of the thread on one of the available cores. 
> The application-level structures include the call stack for storing function calls and the structures the application needs to manage and manipulate the thread’s attributes and state.

线程是在应用程序内部实现多个执行路径的相对轻量级的方式。从技术角度来看，线程就是一个管理代码执行所需的内核级（**kernel-level**）和应用级（**application-level**）数据结构的组合。

* 内核级结构协助调度事件到线程，并抢占式调度这个线程到一个可用的内核上。
* 应用级结构包括用于存储函数调用的调用堆栈和应用程序需要管理和操作的线程属性和状态的结构。

在应用程序中使用多线程有两个非常重要的潜在好处：

* 多个线程可以提高应用程序的感知响应。
* 多个线程可以提高应用程序在多核系统上的实时性能。

同时，在应用程序中使用多线程的潜在问题：

* 应用程序内拥有多个可执行路径，会给你的代码增加更多的复杂性。
* 每个线程需要和其他线程协调其行为，以防止它破坏应用程序的状态信息。因为应用程序内的多个线程共享内存空间，它们访问相同的数据结构。如果两个线程试图同时处理相同的数据结构，一个线程有可能覆盖另外线程的改动导致破坏该数据结构。
* 即使有适当的保护，你仍然要注意由于编译器的优化导致给你代码产生很微妙的（和不那么微妙）的 Bug。

## 1.2 线程术语（Threading Terminology）

在讨论线程及其支持技术之前，有必要定义一些基本术语：

* 线程(thread)用于指代独立执行的代码段。
* 进程(process)用于指代一个正在运行的可执行程序，它可以包含多个线程。 
* 任务(task)用于指代抽象的概念，表示需要执行工作。 

## 1.3 线程的替代方法（Alternatives to Threads）

因为线程是一个相对底层和复杂的方式来支持应用程序并发，很可能会遇到同步或定时问题。

多线程解决了如何在同一个进程内并发的执行多路代码路径的问题。但是引入多线程也会带来大量的开销，包括内存消耗和 CPU 占用。如果这些开销对于你的预期工作而言实在太大，或者有其他更容易实现的方法，我们应该考虑是否真的需要多线程或并发。

表 1-1 列举了多线程的替代方法。该表包含了多线程的替代技术(比如 operation objects 和 GCD)和如何更高效的使用单个线程。

Table 1-1 A lternative technologies to threads

Technology | Description
-|:-:
Operation objects | Introduced in OS X v10.5, an operation object is a wrapper for a task that would normally be executed on a secondary thread. This wrapper hides the thread management aspects of performing the task, leaving you free to focus on the task itself. You typically use these objects in conjunction with an operation queue object, which actually manages the execution of the operation objects on one or more threads.For more information on how to use operation objects, see Concurrency Programming Guide.
Grand Central Dispatch (GCD)|Introduced in Mac OS x v10.6, Grand Central Dispatch is another alternative to threads that lets you focus on the tasks you need to perform rather than on thread management. With GCD, you define the task you want to perform and add it to a work queue, which handles the scheduling of your task on an appropriate thread. Work queues take into account the number of available cores and the current load to execute your tasks more efficiently than you could do yourself using threads.For information on how to use GCD and work queues, see Concurrency Programming Guide
Idle-time notifications|For tasks that are relatively short and very low priority, idle time notifications let you perform the task at a time when your application is not as busy. Cocoa provides support for idle-time notifications using the NSNotificationQueue object. To request an idle-time notification, post a notification to the default NSNotificationQueue object using the NSPostWhenIdle option. The queue delays the delivery of your notification object until the run loop becomes idle. For more information, see Notification Programming Topics.
Asynchronous functions|The system interfaces include many asynchronous functions that provide automatic concurrency for you. These APIs may use system daemons and processes or create custom threads to perform their task and return the results to you. (The actual implementation is irrelevant because it is separated from your code.) As you design your application, look for functions that offer asynchronous behavior and consider using them instead of using the equivalent synchronous function on a custom thread.
Timers|You can use timers on your application’s main thread to perform periodic tasks that are too trivial to require a thread, but which still require servicing at regular intervals. For information on timers, see Timer Sources.
Separate processes|Although more heavyweight than threads, creating a separate process might be useful in cases where the task is only tangentially related to your application. You might use a process if a task requires a significant amount of memory or must be executed using root privileges. For example, you might use a 64-bit server process to compute a large data set while your 32-bit application displays the results to the user.

Warnning：使用 `fork` 函数启动单独的进程时，你必须总是在 `fork` 后面调用 `exec` 或者类似的函数。基于 **Core Foundation**、**Cocoa** 或者 **Core Data** 框架（无论显式还是隐式关联）的应用程序必须对 `exec` 函数进行后续调用，否则这些框架的行为可能会不正确。

## 1.4 线程支持(Threading Support)

**Mac OS** 和 **iOS** 提供了多种技术来在应用程序中创建线程。此外，这两个系统还为管理和同步这些线程上需要完成的工作提供支持。以下各节介绍了在 **Mac OS** 和 **iOS** 中使用线程时需要注意的一些关键技术。

### 1.4.1 线程包(Threading Packages)

底层实现机制是 Mach 线程，但是我们通常使用更方便的 POSIX API 或其衍生工具, 很少（甚至从不）在 Mach 层面上使用线程。 


Table 1-2 Thread technologies

Technology| Description
-|:-:
Cocoa threads|Cocoa implements threads using the NSThread class. Cocoa also provides methods on NSObject for spawning new threads and executing code on already-running threads. For more information, see “Using NSThread” and “Using NSObject to Spawn a Thread.”
POSIX threads|POSIX threads provide a C-based interface for creating threads. If you are not writing a Cocoa application, this is the best choice for creating threads. The POSIX interface is relatively simple to use and offers ample flexibility for configuring your threads. For more information, see “Using POSIX Threads”
Multiprocessing Services| Multiprocessing Services is a legacy C-based interface used by applications transitioning from older versions of Mac OS. This technology is available in Mac OS X only and should be avoided for any new development. Instead, you should use the NSThread class or POSIX threads. If you need more information on this technology, see Multiprocessing Services Programming Guide.

线程启动之后，线程就进入三个状态中的任何一个:运行(running)、就绪(ready)、阻塞(blocked), 线程持续在这三个状态之间切换，直到它最终退出或者进入中断状态。

我们创建一个新的线程，必须指定该线程的入口点函数。该入口点函数由你想要在该线程上面执行的代码组成。但函数返回的时候，或你显式的中断线程的时候，线程永久停止，且被系统回收。因为线程创建需要的内存和时间消耗都比较大，因此建议你的入口点函数做相当数量的工作，或建立一个 runloop 允许进行经常性的工作。

### 1.4.2 Run Loops

run loop 是用来在线程上管理事件异步到达的基础设施。一个 run loop 为线程监测一个或多个事件源。当事件到达的时候，系统唤醒线程并调度事件到 run loop,然后分配给指定程序。如果没有事件出现和准备处理，run loop 把线程置于休眠状态。

你创建线程的时候不需要使用一个 run loop，但是如果你这么做的话可以给用户带来更好的体验。Run Loops 可以让你使用最小的资源来创建长时间运行线程。因为 run loop 在没有任何事件处理的时候会把它的线程置于休眠状态，它消除了消耗 CPU 周期轮询，并防止处理器本身进入休眠状态并节省电源。

为了配置 run loop,你所需要做的是启动你的线程，获取 run loop 的对象引用，设置你的事件处理程序，并告诉 run loop 运行。Cocoa 和 Carbon 提供的基础设施会自动为你的主线程配置相应的 run loop。如果你打算创建长时间运行的辅助线程，那么你必须为你的线程配置相应的 run loop。

### 1.4.3 同步工具(Synchronization Tools)

如果多个线程在同一个时间试图使用或者修改同一个资源，就会出现问题。缓解该资源争夺的方法之一是消除共享资源，并确保每个线程都有在它操作的资源上面的独特设置。因为保持完全独立的资源是不可行的，所以你可能必须使用锁，条件，原子操作和其他技术来同步资源的访问。

锁提供了一次只有一个线程可以执行代码的有效保护形式。最普遍的一种锁是互斥排他锁，也就是我们通常所说的“mutex”。当一个线程试图获取一个当前已经被其他线程占据的互斥锁的时候，它就会被阻塞直到其他线程释放该互斥锁。系统的几个框架提供了对互斥锁的支持，虽然它们都是基于相同的底层技术。此外 Cocoa 提供了几个互斥锁的变种来支持不同的行为类型，比如递归等。

除了锁，系统还提供了条件，确保在你的应用程序任务执行的适当顺序。条件作为一个看门人，阻塞给定的线程，直到它代表的条件变为真。当发生这种情况的时候，条件释放该线程并允许它继续执行。POSIX 级别和基础框架都直接提供了条件的支持。（如果使用**operation objects**，可以配置你的**operation objects**之间的依赖关系的顺序来确定任务的执行顺序，这和条件提供的行为非常相似）。

尽管锁和条件在并发设计中使用非常普遍，原子操作也是另外一种保护和同步访问数据的方法。原子操作可以对标量数据类型执行数学或逻辑运算的时候提供了替代锁的轻量级的方法。原子操作使用特殊的硬件指令来确保在其他线程有机会访问变量之前完成对变量的修改。


### 1.4.4 线程间通信(Inter-thread Communication)

虽然一个良好的设计最大限度地减少所需的通信量，但在某些时候，线程之间的通信显得十分必要。线程可能需要处理新的工作要求，或向你应用程序的主线程报告其进度情况。在这些情况下，你需要一个方式来从其他线程获取信息。幸运的是，线程共享相同的进程空间，意味着你可以有大量的可选项来进行通信。

线程间通信有很多种方法，每种都有它的优点和缺点。“配置线程局部存储”列出了很多你可以在 Mac OS 上面使用的通信机制。（异常的消息队列和 Cocoa 分布式对象，这些技术也可在 iOS 用来通信）。本表中的技术是按照复杂性的顺序列出。

Table 1-3 Communication mechanisms

Mechanism | Description
-|:-:
Direct messaging|Cocoa applications support the ability to perform selectors directly on other threads. This capability means that one thread can essentially execute a method on any other thread. Because they are executed in the context of the target thread, messages sent this way are automatically serialized on that thread. For information about input sources, see “Cocoa Perform Selector Sources.”
Global variables, shared memory, and objects|Another simple way to communicate information between two threads is to use a global variable, shared object, or shared block of memory. Although shared variables are fast and simple, they are also more fragile than direct messaging. Shared variables must be carefully protected with locks or other synchronization mechanisms to ensure the correctness of your code. Failure to do so could lead to race conditions, corrupted data, or crashes.
Conditions | Conditions are a synchronization tool that you can use to control when a thread executes a particular portion of code. You can think of conditions as gate keepers, letting a thread run only when the stated condition is met. For information on how to use conditions, see “Using Conditions.”
Run loop sources| A custom run loop source is one that you set up to receive application-specific messages on a thread. Because they are event driven, run loop sources put your thread to sleep automatically when there is nothing to do, which improves your thread’s efficiency. For information about run loops and run loop sources, see “Run Loops.”
Ports and sockets| Port-based communication is a more elaborate way to communication between two threads, but it is also a very reliable technique. More importantly, ports and sockets can be used to communicate with external entities, such as other processes and services. For efficiency, ports are implemented using run loop sources, so your thread sleeps when there is no data waiting on the port. For information about run loops and about port-based input sources, see “Run Loops.”
Message queues| The legacy Multiprocessing Services defines a first-in, first-out (FIFO) queue abstraction for managing incoming and outgoing data. Although message queues are simple and convenient, they are not as efficient as some other communications techniques. For more information about how to use message queues, see Multiprocessing Services Programming Guide.
Cocoa distributed objects| Distributed objects is a Cocoa technology that provides a high-level implementation of port-based communications. Although it is possible to use this technology for inter-thread communication, doing so is highly discouraged because of the amount of overhead it incurs. Distributed objects is much more suitable for communicating with other processes, where the overhead of going between processes is already high. For more information, seeDistributed Objects Programming Topics.

## 1.5 设计技巧(Design Tips)

以下各节帮助你实现自己的线程提供了指导，以确保代码的正确性。部分指南同时提供如何利用你的线程代码获得更好的性能。任何性能的技巧，你应该在更改代码之前、期间、之后总是收集相关的性能统计数据。

### 1.5.1 避免显式创建线程（Avoid Creating Threads Explicitly）

手动编写线程创建代码是乏味的，而且容易出现错误，你应该尽可能避免这样做。Mac OS X 和 iOS 通过其他 API 接口提供了隐式的并发支持。你可以考虑使用 asynchronous APIs、GCD 或者 **operation objects** 来实现并发，而不是自己创建一个线程。这些技术背后为你做了线程相关的工作，并保证是无误的。此外，比如 GCD 和 **operation objects** 技术被设计用来管理线程，比通过自己的代码根据当前的负载调整活动线程的数量更高效。 关于更多 GCD 和 **operation objects** 的信息，你可以查阅[Concurrency ProgrammingGuid](https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091)。

### 1.5.2 保持你的线程合理的忙（Keep Your Threads Reasonably Busy）

如果你准备人工创建和管理线程，记得多线程消耗系统宝贵的资源。你应该尽最大努力确保任何你分配到线程的任务是运行相当长时间和富有成效的。同时你不应该害怕中断那些消耗最大空闲时间的线程。线程占用一定量的内存，其中一些是有线的，所以释放空闲线程不但帮助你减少了你应用程序的内存印记，而且还能释放出更多的物理内存给其他系统进程使用。

重要:在你中断你的空闲线程开始之前，你必须总是记录你应用程序当前的性能基线测量。当你尝试修改后，采取额外的测量来确保你的修改实际上提高了性能，而不是对它操作损害。 

### 1.5.3 避免共享数据结构(Avoid Shared Data Structures)

避免造成线程相关资源冲突的最简单最容易的办法是给你应用程序的每个线程一份它需求的数据的副本。当最小化线程之间的通信和资源争夺时并行代码的效果最好。

创建多线程的应用是很困难的。即使你非常小心，并且在你的代码里面所有正确的地方锁住共享资源，你的代码依然可能语义不安全的。比如，当在一个特定的顺序里面修改共享数据结构的时候，你的代码有可能遇到问题。以原子方式修改你的代码，来弥补可能随后对多线程性能产生损耗的情况。把避免资源争夺放在首位通常可以得到简单的设计同样具有高性能的效果。

### 1.5.4 线程和你的用户界面(Threads and Your User Interface)

如果你的应用程序具有一个图形用户界面，建议你在主线程里面接收和界面相关的事件和初始化更新你的界面。这种方法有助于避免与处理用户事件和窗口绘图相关的同步问题。一些框架，比如 Cocoa,通常需要这样操作，但是它的事件处理可以不这样做，在主线程上保持这种行为的优势在于简化了管理你应用程序用户界面的逻辑。

有几个显著的例外，它有利于在其他线程执行图形操作。比如，QuickTime API 包含了一系列可以在辅助线程执行的操作，包括打开视频文件，渲染视频文件，压缩视频文件，和导入导出图像。类似的，在 Carbon 和 Cocoa 里面，你可以使用辅助线程来创建和处理图片和其他图片相关的计算。使用辅助线程来执行这些操作可以极大提高性能。如果你不确定一个操作是否和图像处理相关，那么你应该在主线程执行这些操作。

关于 QuickTime 线程安全的信息，查阅 Technical Note TN2125:“QuickTime 的线程安全编程”。关于 Cocoa 线程安全的更多信息，查阅“线程安全总结”。关于 Cocoa 绘画信息，查阅 Cocoa 绘画指南（Cocoa Drawing Guide）。

### 1.5.5 了解线程退出时的行为(Be Aware of Thread Behaviors at Quit Time)

进程一直运行直到所有非独立线程都已经退出为止。默认情况下，只有应用程序的主线程是以非独立的方式创建的，但是你也可以使用同样的方法来创建其他线程。当用户退出程序的时候，通常考虑适当的立即中断所有独立线程，因为通常独立线程所做的工作都是是可选的。如果你的应用程序使用后台线程来保存数据到硬盘或者做其他周期行的工作，那么你可能想把这些线程创建为非独立的来保证程序退出的时候不丢失数据。

以非独立的方式创建线程（又称作为可连接的）你需要做一些额外的工作。因为大部分上层线程封装技术默认情况下并没有提供创建可连接的线程，你必须使用POSIX API 来创建你想要的线程。此外，你必须在你的主线程添加代码，来当它们最终退出的时候连接非独立的线程。更多有关创建可连接的线程信息，请查阅“设置线程的脱离状态”部分。

如果你正在编程 Cocoa 的程序，你也可以通过使用 `applicationShouldTerminate:` 的委托方法来延迟程序的中断直到一段时间后或者完成取消。当延迟中断的时候，你的程序需要等待直到任何周期线程已经完成它们的任务且调用了 `replyToApplicationShouldTerminate:` 方法。关于更多这些方法的信息，请查阅 NSApplication Class Reference。

###  1.5.6 处理异常(Handle Exceptions)

当抛出一个异常时，异常的处理机制依赖于当前调用堆栈执行任何必要的清理。因为每个线程都有它自己的调用堆栈，所以每个线程都负责捕获它自己的异常。如果在辅助线程里面捕获一个抛出的异常失败，那么你的主线程也同样捕获该异常失败：它所属的进程就会中断。你无法捕获同一个进程里面其他线程抛出的异常。

如果你需要通知另一个线程（比如主线程）当前线程中的一个特殊情况，你应该捕捉异常，并简单地将消息发送到其他线程告知发生了什么事。根据你的模型和你正在尝试做的事情，引发异常的线程可以继续执行（如果可能的话），等待指示，或者干脆退出。

注意:在 Cocoa 里面，一个 NSException 对象是一个自包含对象，一旦它被引发了，那么它
可以从一个线程传递到另外一个线程。

在一些情况下，异常处理可能是自动创建的。比如，Objective-C 中的 @synchronized 包含了一个隐式的异常处理。

### 1.5.7 干净地中断你的线程(Terminate Your Threads Cleanly)

线程自然退出的最好方式是让它达到其主入口结束点。虽然有不少函数可以用来立即中断线程，但是这些函数应仅用于作为最后的手段。在线程达到它自然结束点之前中断一个线程阻碍该线程完成清理它自己。如果线程已经分配了内存，打开了文件，或者获取了其他类型资源，你的代码可能没办法回收这些资源，结果造成内存泄漏或者其他潜在的问题。

### 1.5.8 线程安全的库(Thread Safety in Libraries)

虽然应用程序开发人员控制应用程序是否执行多个线程，类库的开发者则无法这样控制。当开发类库时，你必须假设调用应用程序是多线程，或者多线程之间可以随时切换。因此你应该总是在你的临界区使用锁功能。

对类库开发者而言，只当应用程序是多线程的时候才创建锁是不明智的。如果你需要锁定你代码中的某些部分，早期应该创建锁对象给你的类库使用，更好是显式调用初始化类库。虽然你也可以使用静态库的初始化函数来创建这些锁，但是仅当没有其他方式的才应该这样做。执行初始化函数需要延长加载你类库的时间，且可能对你程序性能造成不利影响。

注意：永远记住在你的类库里面保持锁和释放锁的操作平衡。你应该总是记住锁定类库的数据结构，而不是依赖调用的代码提供线程安全环境。

如果你真正开发 Cocoa 的类库，那么当你想在应用程序变成多线程的时候收到通知的话，你可以给 `NSWillBecomeMultiThreadedNotification` 注册一个观察者。不过你不应用依赖于这些收到的通知，因为它们可能在你的类库被调用之前已经被发出了。

