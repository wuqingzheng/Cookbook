## 3.3 使用 Run Loop 对象

**Run loop 对象** 提供了添加**输入源**、**定时器**、 **run loop 观察者** 以及 **启动 run loop 的接口**。每个线程都有唯一的与之关联的 **run loop 对象**。在 **Cocoa** 中，该对象是 **NSRunLoop** 类的一个实例，而在 **Carbon** 或 **BSD** 程序中则是一个指向 **CFRunLoopRef** 类型的指针。

### 3.3.1 获得 Run Loop 对象

为了获得当前线程的 **run loop**，你可以采用以下任一方式：
* 在 Cocoa 程序中，使用 NSRunLoop 的 currentRunLoop 类方法来检索一个 NSRunLoop 对象。
* 使用 CFRunLoopGetCurrent 函数。

虽然它们并不是完全相同的类型，但是你可以在需要的时候从 **NSRunLoop** 对象中获取 **CFRunLoopRef** 类型。**NSRunLoop** 类定义了一个 **getCFRunLoop** 方法，该方法返回一个可以传递给 **Core Foundation** 例程的 **CFRunLoopRef** 类型。因为两者都指向同一个 **run loop**，你可以在需要的时候混合使用 **NSRunLoop** 对象和 **CFRunLoopRef** 不透明类型。

### 3.3.2 配置 Run Loop

在你在辅助线程运行 **run loop** 之前，你必须至少添加一输入源或定时器给它。如果 run loop 没有任何源需要监视的话，它会在你启动之际立马退出。关于如何添加源到 **run loop** 里面的例子，参阅”配置 Run Loop 的源”。

除了添加源，你也可以添加 **run loop 观察者**来监视 **run loop** 的不同执行阶段情况。为了给 **run loop** 添加一个观察者，你可以创建 **CFRunLoopObserverRef** 不透明类型，并使用 `CFRunLoopAddObserver` 将它添加到你的 **run loop**。**Run loop 观察者**必须由 **Core foundation** 函数创建，即使是 Cocoa 程序。

Listing 3-1 显示了添加一个 **run loop 的观察者**到它的 **run loop** 的线程主体例程。该例子的主要目的是显示如何创建一个 **run loop 观察者**，所以该代码只是简单的设置一个观察者来监视 **run loop** 的所有活动。基础处理程序(没有显示)只是简单的打印出 **run loop** 处理定时器请求的活动信息。

<p align=center>Listing 3-1  Creating a run loop observer

``` Objective-C
- (void)threadMain
{
 // The application uses garbage collection, so no autorelease pool is needed.
 NSRunLoop* myRunLoop = [NSRunLoop currentRunLoop];
 
 // Create a run loop observer and attach it to the run loop.
 CFRunLoopObserverContext context = {0, self, NULL, NULL, NULL};
 CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,
  kCFRunLoopAllActivities, YES, 0, &myRunLoopObserver, &context);
 if (observer)
 {
    CFRunLoopRef cfLoop = [myRunLoop getCFRunLoop];
    CFRunLoopAddObserver(cfLoop, observer, kCFRunLoopDefaultMode);
 }
 
 // Create and schedule the timer.
 [NSTimer scheduledTimerWithTimeInterval:0.1 target:self
 selector:@selector(doFireTimer:) userInfo:nil repeats:YES];
 NSInteger loopCount = 10;
 do
 {
    // Run the run loop 10 times to let the timer fire.
    [myRunLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1]];
    loopCount--;
  }
 while (loopCount);
}
```

当当前长时间运行的线程配置 **run loop** 的时候，最好添加至少一个输入源到 **runloop** 以接收消息。虽然你可以使用添加的定时器来进入 **run loop**，但是一旦定时器触发后，它通常就变为无效了，这会导致 **run loop** 退出。虽然附加一个循环的定时器可以让 **run loop** 运行一个相对较长的周期，但是这也会导致周期性的唤醒线程，这实际上是轮询（polling）的另一种形式而已。与之相反，输入源会一直等待某事件发生，在事情导致前它让线程处于休眠状态。

### 3.3.3 启动 Run Loop

启动 **run loop** 只对程序的辅助线程有意义。一个 **run loop** 通常必须包含一个输入源或定时器来监听事件。如果一个都没有，**run loop** 启动后立即退出。有几种方式可以启动 **run loop**,包括以下这些:

* 无条件的（Unconditionally）
* 设置超时时间（With a set time limit）
* 特定的模式（In a particular mode）

无条件的进入 **run loop** 是最简单的方法，但也最不推荐使用的。因为这样会使你的线程处在一个永久的循环中，这会让你对 **run loop** 本身的控制很少。你可以添加或删除输入源和定时器，但是退出 **run loop** 的唯一方法是杀死它。 在自定义模式下也无法运行 **run loop**。

替代无条件进入 **run loop** 更好的办法是用预设超时时间来运行 **run loop**，这样 **run loop** 运作直到某一事件到达或者规定的时间已经到期。如果是事件到达，消息会被传递给相应的处理程序来处理，然后 **run loop** 退出。你可以重新启动 ** run loop** 来等待下一事件。如果是规定时间到期了，你只需简单的重启 run loop 或使用此段时间来做任何的其他工作。

除了超时机制，你也可以使用特定的模式来运行你的 **run loop**。模式和超时不是互斥的，他们可以在启动 **run loop** 的时候同时使用。模式限制了可以传递事件给 **runloop** 的输入源的类型，这在”Run Loop 模式”部分介绍。

Listing 3-2 描述了线程的主要例程的架构。本示例的关键是说明了 **run loop** 的基本结构。本质上讲你添加自己的输入源或定时器到 **run loop** 里面，然后重复的调用一个程序来启动 **run loop**。每次 **run loop** 返回的时候，你需要检查是否有使线程退出的条件成立。示例中使用了 **Core Foundation** 的 **run loop** 例程，以便可以检查返回结果从而确定 **run loop** 为何退出。若是在 **Cocoa** 程序，你也可以使用 **NSRunLoop** 的方法运行 **run loop**，无需检查返回值。（关于使用 **NSRunLoop** 返回运行 **run loop** 的例子，查看列表 3-12）

<p align=center> Listing 3-2 Running a run loop

```Objective-C
- (void)skeletonThreadMain
{
 // Set up an autorelease pool here if not using garbage collection.
 BOOL done = NO;
 // Add your sources or timers to the run loop and do any other setup.
 do
 {
 // Start the run loop but return after each source is handled.
 SInt32 result = CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, YES);
 // If a source explicitly stopped the run loop, or if there are no
 // sources or timers, go ahead and exit.
 if ((result == kCFRunLoopRunStopped) || (result == kCFRunLoopRunFinished))
 done = YES;
 // Check for any other exit conditions here and set the
 // done variable as needed.
 }
 while (!done);
 // Clean up code here. Be sure to release any allocated autorelease pools.
 }
```

可以递归的运行 run loop。 换句话说你可以使用 CFRunLoopRun ，CFRunLoopRunInMode 或者任一 NSRunLoop 的方法在输入源或定时器的处理程序里面启动 run loop。这样做的话，你可以使用任何模式启动嵌套的 run loop，包括被外层 run loop 使用的模式。


### 3.3.4 退出 Run Loop

有两种方法可以让 **run loop** 处理事件之前退出:
* 给 run loop 设置超时时间
* 通知 run loop 停止

如果可以配置的话，推荐使用第一种方法。指定一个超时时间可以使 **run loop** 退出前完成所有正常操作，包括发送消息给 **run loop 观察者**。

使用 CFRunLoopStop 来显式的停止 run loop 和使用超时时间产生的结果相似。Run loop 把所有剩余的通知发送出去再退出。与设置超时的不同的是你可以在无条件启动的 run loop 里面使用该技术。

尽管移除 run loop 的输入源和定时器也可能导致 run loop 退出，但这并不是可靠的退出 run loop 的方法。一些系统例程会添加输入源到 run loop 里面来处理所需事件。因为你的代码未必会考虑到这些输入源，这样可能导致你无法没从系统例程中移除它们，从而阻止 run loop 退出。

### 3.3.5 线程安全和 Run Loop 对象

线程是否安全取决于你使用哪些 API 来操作 run loop。Core Foundation 中的函数通常是线程安全的，可以被任意线程调用。但是如果你修改了 run loop 的配置然后需要执行某些操作，任何时候你最好还是在 run loop 所属的线程执行这些操作。

至于 Cocoa 的 NSRunLoop 类则不像 Core Foundation 具有与生俱来的线程安全性。如果你想使用 NSRunLoop 类来修改你的 run loop，你应用在 run loop 所属的线程里面完成这些操作。给属于不同线程的 run loop 添加输入源和定时器有可能导致你的代码崩溃或产生不可预知的行为。

