## 3.1 Run Loop 剖析

> Your code provides the control statements used to implement the actual loop portion of the run loop—in other words, your code provides the while or for loop that drives the run loop. Within your loop, you use a run loop object to "run” the event-processing code that receives events and calls the installed handlers.

**Run loop** 本身听起来就和它的名字很像。它是一个循环，您的线程进入并用它来运行事件处理程序以响应传入事件。您的代码提供了用于实现 **run loop** 实际循环部分的控制语句 - 换言之就是你的代码中要有 **while** 或 **for** 循环语句来驱动 **run loop**。 在循环中，使用**run loop object** 来“运行”接收事件并调用已安装的处理程序的事件处理代码。

**Run loop** 接收来自两种不同的来源输入事件,两种源都使用程序的某一特定的处理例程来处理到达的事件：
* 输入源（input source）,输入源传递异步事件，通常消息来自于其他线程或程序
* 定时源（timer source）,定时源则传递同步事件，发生在特定时间或者重复的时间间隔

输入源传递异步消息给相应的处理例程，并调用 `runUntilDate:` 方法来退出(在线程里面相关的 **NSRunLoop** 对象调用)。定时源则直接传递消息给处理例程，但并不会退出 **run loop**。

图 3-1 显示了 run loop 的概念结构以及各种源。

<p align=center>Figure 3-1 Structure of a run loop and its sources</p>

![](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg)

除了处理输入源，**run loops** 也会生成关于 **run loop** 行为的通知(**notifications**)。注册的 **run loop** 观察者(**run-loop Observers**)可以收到这些通知，并在线程上面使用它们来做额外的处理。你可以使用 **Core Foundation** 在你的线程注册 **run-loop** 观察者。

下面部分介绍更多关于 **run loop** 的构成，以及其运行的模式。同时也提及在处理事件中不同时间生成的通知。

### 3.1.1 Run Loop 模式

**Run loop** 模式是所有要监视的输入源和定时源以及要通知的 **run loop** 注册观察者的集合。每次运行你的 **run loop**，你都要指定（无论显示还是隐式）其运行模式。在 **run loop** 运行过程中，只有和模式相关的源才会被监视并允许他们传递事件消息（类似的，只有和模式相关的观察者会被通知 **run loop** 的进程）。和其他模式关联的源只有在 **run loop** 运行在其模式下才会运行，否则处于暂停状态。

通常在你的代码中，你可以通过指定名字来标识模式。**Cocoa** 和 **Core Foundation** 定义了一个默认的和一些常用的模式，在你的代码中都是用字符串来标识这些模式。当然你也可以给模式名称指定一个字符串来自定义模式。虽然你可以给模式指定任意名字，但是模式的内容则不能是任意的。你必须添加一个或多个输入源、定时源或者 **run-loop Observers** 到你新建的模式中让他们有价值。

通过指定模式可以使得 **run loop** 在某一阶段过滤来源于源的事件。大多数时候，**run loop** 都是运行在系统定义的默认模式上。但是模态面板（**modal panel**）可以运行在 “modal”模式下。在这种模式下，只有和模式面板相关的源才可以传递消息给线程。对于辅助线程，你可以使用自定义模式在一个时间周期操作上屏蔽优先级低的源传递消息。

注意：模式区分基于事件的源而非事件的种类。例如，你不可以使用模式只选择处理鼠标按下或者键盘事件。你可以使用模式监听端口，暂停定时器或者改变其他源或者当前模式下处于监听状态 **run loop 观察者**。

Table 1-3 列出了 **Cocoa** 和 **Core Foundation** 定义的标准模式，并且介绍何时使用他们。名称那列列出了你用来在你代码中指定模式实际的常量。

Table 3-1 Predefined run loop modes

Mode | Name | Description  
-|:-:|:-:
Default | NSDefaultRunLoopMode(Cocoa) kCFRunLoopDefaultMode (CoreFoundation) | 默认模式是用于大多数操作的模式。 大多数情况下，您应该使用此模式启动 run loop 并配置输入源。
Connection | NSConnectionReplyMode(Cocoa) | Cocoa 将此模式与 NSConnection 对象一起使用来 monitor replies。 你应该很少需要自己使用这种模式。
Modal|NSModalPanelRunLoopMode(Cocoa) | Cocoa 使用这种模式来识别用于 modal panels 的事件
Event tracking| NSEventTrackingRunLoopMode(Cocoa)|Cocoa 使用这种模式来限制 mouse-dragging loops 和其他类型的 user interface tracking loops 期间的传入事件。
Common modes| NSRunLoopCommonModes(Cocoa) kCFRunLoopCommonModes (Core Foundation)|这是一个可配置的常用模式组。将输入源与此模式关联也会将其与组中的每个模式相关联。对于 Cocoa 应用程序，默认情况下，此集合包含 Default、Modal和 Event tracking， Core Foundation 最初只包含默认模式，您可以使用CFRunLoopAddCommonMode 函数将自定义模式添加到该集合。

### 3.1.2 输入源

输入源异步的发送消息给你的线程。事件来源取决于输入源的种类：
* 基于端口的输入源（Port-Based Sources）,基于端口的输入源监听程序相应的端口
* 自定义输入源（Custom Input Sources）,自定义输入源则监听自定义的事件源。

至于 **run loop**，它不关心输入源的是基于端口的输入源还是自定义的输入源。系统会实现这两种输入源供你使用。两个源之间的唯一区别是它们如何发出信号：基于端口的输入源由内核自动发送，而自定义的则需要手动从其他线程发送。

当你创建输入源，你需要将其分配给 **run loop** 中的一个或多个模式。模式只会在特定事件影响监听的源。大多数情况下，**run loop** 运行在默认模式下，但是你也可以使其运行在自定义模式。若某一源在当前模式下不被监听，那么任何其生成的消息只在 **run loop** 运行在其关联的模式下才会被传递。

#### 基于端口的输入源 

**Cocoa** 和 **Core Foundation** 内置支持使用端口相关的对象和函数来创建的基于端口的源。例如，在 **Cocoa** 里面你从来不需要直接创建输入源。你只要简单的创建端口对象，并使用 **NSPort** 的相关方法把该端口添加到 **run loop**。端口对象会自己处理创建和配置输入源。

在 **Core Foundation**，你必须手动创建端口和它的 **run loop** 源.在两种情况下，你都可以使用端口相关的函数（CFMachPortRef，CFMessagePortRef，CFSocketRef）来创建合适的对象。

更多例子关于如何设置和配置一个自定义端口源，参阅[Configuring a Port-Based Input Source.](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-131281)部分。

#### 自定义输入源

为了创建自定义输入源，必须使用 **Core Foundation** 里面的 **CFRunLoopSourceRef** 类型相关的函数来创建。你可以使用回调函数来配置自定义输入源。**Core Fundation** 会在配置源的不同地方调用回调函数，处理输入事件，在源从 **run loop** 移除的时候清理它。

除了定义在事件到达时自定义输入源的行为，你也必须定义消息传递机制。源的这部分运行在单独的线程里面，并负责在数据等待处理的时候传递数据给源并通知它处理数据。消息传递机制的定义取决于你，但最好不要过于复杂。

关于创建自定义输入源的例子，参阅 [Defining a Custom Input Source](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW3)。关于自定义输入源的信息，参阅 [CFRunLoopSource Reference](https://developer.apple.com/documentation/corefoundation/cfrunloopsource-rhr)。

#### Cocoa 执行 Selector 的源 

除了基于端口的源，**Cocoa** 定义了自定义输入源，允许你在任何线程执行 **selector**。和基于端口的源一样，执行 **selector** 请求会在目标线程上序列化，减缓许多在线程上允许多个方法容易引起的同步问题。不像基于端口的源，一个 **selector** 执行完后会自动从 **run loop** 里面移除。

注意:在 Mac OS X 10.5 之前，执行 **selector** 多半可能是给主线程发送消息，但是在 Mac OS X 10.5 及其之后和在 iOS 里面，你可以使用它们给任何线程发送消息。

当在其他线程上面执行 **selector** 时，目标线程须有一个活动的 **run loop**。对于你创建的线程，这意味着线程在你显式的启动 **run loop** 之前处于等待状态。由于主线程自己启动它的 **run loop**，那么在程序通过委托调用 
```applicationDidFinishlaunching:```
的时候你会遇到线程调用的问题。因为 **Run loop** 通过每次循环来处理所有队列的 **selector** 的调用，而不是通过 **loop** 的迭代来处理 **selector**。

Table 3-2 列出了 **NSObject** 中可在其它线程执行的 **selector**。由于这些方法是定义在 **NSObject** 中，你可以在任何可以访问 **Objective-C** 对象的线程里面使用它们，包括 **POSIX** 的所有线程。这些方法实际上并没有创建新的线程执行 **selector**。

Table 3-2 Performing selectors on other threads

Methods | Description  
-|:-:
performSelectorOnMainThread:withObject:waitUntilDone:<br>performSelectorOnMainThread:withObject:waitUntilDone:modes: | Performs the specified selector on the application’s main thread during that thread’s next run loop cycle. These methods give you the option of blocking the current thread until the selector is performed.
performSelector:onThread:withObject:waitUntilDone: <br>performSelector:onThread:withObject:waitUntilDone:modes: | Performs the specified selector on any thread for which you have an NSThreadobject. These methods give you the option of blocking the current thread until the selector is performed.
performSelector:withObject:afterDelay:<br>performSelector:withObject:afterDelay:inModes: | Performs the specified selector on the current thread during the next run loop cycle and after an optional delay period. Because it waits until the next run loop cycle to perform the selector, these methods provide an automatic mini delay from the currently executing code. Multiple queued selectors are performed one after another in the order they were queued.
cancelPreviousPerformRequestsWithTarget:<br>cancelPreviousPerformRequestsWithTarget:selector:object:|Lets you cancel a message sent to the current thread using the <br>performSelector:withObject:afterDelay:<br>or performSelector:withObject:afterDelay:inModes: <br>method.

关于更多介绍这些方法的信息，参阅 NSObject Class Reference。


#### 定时源 

定时源在预设的时间点同步方式传递消息。定时器是线程通知自己做某事的一种方法。例如，搜索控件可以使用定时器，当用户连续输入的时间超过一定时间时，就开始一次搜索。这样使用延迟时间，就可以让用户在搜索前有足够的时间来输入想要搜索的关键字。

尽管定时器可以产生基于时间的通知，但它并不是实时机制。和输入源一样，定时器也和你的 **run loop** 的特定模式相关。如果定时器所在的模式当前未被 run loop 监视，那么定时器将不会开始直到 **run loop** 运行在相应的模式下。类似的，如果定时器在 **run loop** 处理某一事件期间开始，定时器会一直等待直到下次 run loop 开始相应的处理程序。如果 run loop 不再运行，那定时器也将永远不启动。

你可以配置定时器工作仅一次还是重复工作。重复工作定时器会基于安排好的时间而非实际时间调度它自己运行。举个例子，如果定时器被设定在某一特定时间开始并 **5** 秒重复一次，那么定时器会在那个特定时间后 **5** 秒启动，即使在那个特定的触发时间延迟了。如果定时器被延迟以至于它错过了一个或多个触发时间，那么定时器会在下一个最近的触发事件启动，而后面会按照触发间隔正常执行。

关于更多配置定时源的信息，参阅“配置定时源”部分。关于引用信息，查看 NSTimer Class Reference 或 CFRunLoopTimer Reference。

### 3.1.3 Run Loop 观察者
源是在合适的同步或异步事件发生时触发，而 **run loop 观察者** 则是在 **run loop** 本身运行的特定时候触发。你可以使用 **run loop 观察者**来为处理某一特定事件或是进入休眠的线程做准备。你可以将 **run loop 观察者**和以下事件关联：

* Run loop 入口
* Run loop 何时处理一个定时器
* Run loop 何时处理一个输入源
* Run loop 何时进入睡眠状态
* Run loop 何时被唤醒，但在它处理了唤醒它的事件之前。
* Run loop 终止

您可以使用 **Core Foundation** 将 **run loop 观察者** 添加到应用程序。为了创建一个 **Run Loop 观察者**，你可以创建了一个 **CFRunLoopObserverRef** 不透明类型的新实例。 此类型会跟踪您的自定义回调函数以及它感兴趣的活动。

和定时器类似，**run loop 观察者** 可以只用一次或循环使用。若只用一次，那么在
它启动后，会把它自己从 **run loop** 里面移除，而循环的观察者则不会。你在创建 **run
loop 观察者** 的时候需要指定它是运行一次还是多次。

关于如何创建一个 **run loop 观察者**的实例，参阅“配置 run loop”部分。关于更多的相关信息，参阅 CFRunLoopObserver Reference。

### 3.1.4 Run Loop 的事件队列
每次运行 **run loop**，你线程的 **run loop** 对会自动处理之前未处理的消息，并通知相关的观察者。具体的顺序如下：

1. 通知观察者 run loop 已经启动
2. 通知观察者任何即将要开始的定时器
3. 通知观察者任何即将启动的非基于端口的源
4. 启动任何准备好的非基于端口的源
5. 如果基于端口的源准备好并处于等待状态，立即启动；并进入步骤 9。
6. 通知观察者线程进入休眠
7. 将线程置于休眠直到任一下面的事件发生：
  ** 某一事件到达基于端口的源
  ** 定时器启动
  ** Run loop 设置的时间已经超时
  ** run loop 被显式唤醒
8. 通知观察者线程将被唤醒。
9. 处理未处理的事件
  ** 如果用户定义的定时器启动，处理定时器事件并重启 run loop。进入步骤 2
  ** 如果输入源启动，传递相应的消息
10. 通知观察者 run loop 结束。

因为定时器和输入源的观察者是在相应的事件发生之前传递消息，所以通知的时间和实际事件发生的时间之间可能存在误差。如果需要精确时间控制，你可以使用休眠和唤醒通知来帮助你校对实际发生事件的时间。

因为当你运行 **run loop** 时定时器和其它周期性事件经常需要被传递，撤销 **runloop** 也会终止消息传递。典型的例子就是鼠标路径追踪。因为你的代码直接获取到消息而不是经由程序传递，因此活跃的定时器不会开始直到鼠标追踪结束并将控制权交给程序。

**Run loop** 可以由 **run loop 对象** 显式唤醒。其它消息也可以唤醒 **run loop**。例如，添加新的非基于端口的源会唤醒 **run loop** 从而可以立即处理输入源而不需要等待其他事件发生后再处理。
