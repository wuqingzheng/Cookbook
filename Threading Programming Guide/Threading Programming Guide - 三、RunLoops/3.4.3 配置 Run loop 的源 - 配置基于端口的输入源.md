### 3.4.3 配置 Run loop 的源 - 配置基于端口的输入源

**Cocoa** 和 **Core Foundation** 都提供了基于端口的对象用于线程或进程间的通信。以下部分显示如何使用几种不同类型的端口对象建立端口通信。

#### 配置 NSMachPort 对象 

为了和 **NSMachPort 对象** 建立稳定的本地连接，你需要创建端口对象并将之加入相应的线程的 run loop。当运行辅助线程的时候，你传递端口对象到线程的主体入口点。辅助线程可以使用相同的端口对象将消息返回给原线程。

##### a) 实现主线程的代码 

列表 3-12 显示了加载辅助线程的主线程代码。因为 **Cocoa** 框架执行许多配置端口及 **run loop** 相关的步骤，所以 lauchThread 方法比相应的 Core Foundation 版本（列表 3-17）要明显简短。然而两种方法的本质几乎是一样的，唯一的区别就是在 Cocoa 中直接发送 NSPort 对象，而不是发送本地端口名称。

Listing 3-12 Main thread launch method

``` Objective-C
- (void)launchThread
{
 NSPort* myPort = [NSMachPort port];
 if (myPort)
 {
 // This class handles incoming port messages.
 [myPort setDelegate:self];
 
 // Install the port as an input source on the current run loop.
 [[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRunLoopMode];
 
 // Detach the thread. Let the worker release the port.
 [NSThread detachNewThreadSelector:@selector(LaunchThreadWithPort:)
 toTarget:[MyWorkerClass class] withObject:myPort];
 }
}
```

为了在你的线程间建立双向的通信，你需要让你的工作线程在签到的消息中发送自己的本地端口到主线程。主线程接收到签到消息后就可以知道辅助线程运行正常，并且提供了发送消息给辅助线程的方法。

列表 3-13 显示了主要线程的 handlePortMessage：方法。当由数据到达线程的本地端口时，该方法被调用。当签到消息到达时，此方法可以直接从辅助线程里面检索端口并保存下来以备后续使用。

Listing 3-13 Handling Mach port messages

``` Objective-C
#define kCheckinMessage 100
// Handle responses from the worker thread.
- (void)handlePortMessage:(NSPortMessage *)portMessage
{
 unsigned int message = [portMessage msgid];
 NSPort* distantPort = nil;
 if (message == kCheckinMessage)
 {
 // Get the worker thread’s communications port.
 distantPort = [portMessage sendPort];
 // Retain and save the worker port for later use.
 [self storeDistantPort:distantPort];
 }
 else
 {
 // Handle other messages.
 }
 }
```

##### b) 辅助线程的实现代码

对于辅助工作线程，你必须配置线程使用特定的端口以发送消息返回给主要线程。

列表 3-14 显示了如何设置工作线程的代码。创建了线程的自动释放池后，紧接着创建工作对象驱动线程运行。工作对象的 sendCheckinMessage：方法（如列表 3-15 所示）创建了工作线程的本地端口并发送签到消息回主线程。

Listing 3-14 Launching the worker thread using Mach ports

``` Objective-C
+(void)LaunchThreadWithPort:(id)inData
{
 NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
 
 // Set up the connection between this thread and the main thread.
 NSPort* distantPort = (NSPort*)inData;
 MyWorkerClass* workerObj = [[self alloc] init];
 [workerObj sendCheckinMessage:distantPort];
 [distantPort release];
 // Let the run loop process things.
 do
 {
 [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode
 beforeDate:[NSDate distantFuture]];
 }
 while (![workerObj shouldExit]);
 [workerObj release];
 [pool release];
}
```

当使用 NSMachPort 时候，本地和远程线程可以使用相同的端口对象在线程间进行单边通信。换句话说，一个线程创建的本地端口对象成为另一个线程的远程端口对象。

列表 3-15 显示了辅助线程的签到例程，该方法为之后的通信设置自己的本地端口，然后发送签到消息给主线程。它使用 LaunchThreadWithPort：方法中收到的端口对象做为目标消息。

Listing 3-15 Sending the check-in message using Mach ports

``` Objective-C
// Worker thread check-in method
- (void)sendCheckinMessage:(NSPort*)outPort
{
 // Retain and save the remote port for future use.
 [self setRemotePort:outPort];
 
 // Create and configure the worker thread port.
 NSPort* myPort = [NSMachPort port];
 [myPort setDelegate:self];
 [[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRunLoopMode];
 // Create the check-in message.
 NSPortMessage* messageObj = [[NSPortMessage alloc] initWithSendPort:outPort
 receivePort:myPort components:nil];
 if (messageObj)
 {
 // Finish configuring the message and send it immediately.
 [messageObj setMsgId:setMsgid:kCheckinMessage];
 [messageObj sendBeforeDate:[NSDate date]];
 }
}
```

#### 配置 NSMessagePort 对象 

为了和 NSMeaasgePort 的建立稳定的本地连接，你不能简单的在线程间传递端口对象。远程消息端口必须通过名字来获得。在 Cocoa 中这需要你给本地端口指定一个名字，并将名字传递到远程线程以便远程线程可以获得合适的端口对象用于通信。列表 3-16 显示端口创建，注册到你想要使用消息端口的进程。

Listing 3-16 Registering a message port

``` Objective-C
NSPort* localPort = [[NSMessagePort alloc] init];
// Configure the object and add it to the current run loop.
[localPort setDelegate:self];
[[NSRunLoop currentRunLoop] addPort:localPort forMode:NSDefaultRunLoopMode];
// Register the port using a specific name. The name must be unique.
NSString* localPortName = [NSString stringWithFormat:@"MyPortName"];
[[NSMessagePortNameServer sharedInstance] registerPort:localPort
 name:localPortName];
```


#### 在 Core Foundation 中配置基于端口的源 

这部分介绍了在 Core Foundation 中如何在程序主线程和工作线程间建立双通道通信。

列 表 3-17 显示了程序主线程加载工作线程的代码。第一步是设置 CFMessagePortRef 不透明类型来监听工作线程的消息。工作线程需要端口的名称来建立连接，以便使字符串传递给工作线程的主入口函数。在当前的用户上下文中端口名必须是唯一的，否则可能在运行时造成冲突。

Listing 3-17 Attaching a Core Foundation message port to a new thread

``` C
#define kThreadStackSize (8 *4096)
OSStatus MySpawnThread()
{
 // Create a local port for receiving responses.
 CFStringRef myPortName;
 CFMessagePortRef myPort;
 CFRunLoopSourceRef rlSource;
 CFMessagePortContext context = {0, NULL, NULL, NULL, NULL};
 Boolean shouldFreeInfo;
 // Create a string with the port name.
 myPortName = CFStringCreateWithFormat(NULL, NULL, CFSTR("com.myapp.MainThread"));
 // Create the port.
 myPort = CFMessagePortCreateLocal(NULL,
 myPortName,
 &MainThreadResponseHandler,
 &context,
 &shouldFreeInfo);
 if (myPort != NULL)
 {
 // The port was successfully created.
 // Now create a run loop source for it.
 rlSource = CFMessagePortCreateRunLoopSource(NULL, myPort, 0);
 if (rlSource)
 {
 // Add the source to the current run loop.
 CFRunLoopAddSource(CFRunLoopGetCurrent(), rlSource, kCFRunLoopDefaultMode);
 // Once installed, these can be freed.
 CFRelease(myPort);
 CFRelease(rlSource);
 }
 }
 // Create the thread and continue processing.
 MPTaskID taskID;
 return(MPCreateTask(&ServerThreadEntryPoint,
 (void*)myPortName,
 kThreadStackSize,
 NULL,
 NULL,
 NULL,
 0,
 &taskID));
}
 
 ```


端口建立而且线程启动后，主线程在等待线程签到时可以继续执行。当签到消息到达后，主线程使用 MainThreadResponseHandler 来分发消息，如列表 3-18 所示。这个函数提取工作线程的端口名，并创建用于未来通信的管道。

Listing 3-18 Receiving the checkin message

``` C
#define kCheckinMessage 100
// Main thread port message handler
CFDataRef MainThreadResponseHandler(CFMessagePortRef local,
 SInt32 msgid,
 CFDataRef data,
 void* info)
{
 if (msgid == kCheckinMessage)
 {
 CFMessagePortRef messagePort;
 CFStringRef threadPortName;
 CFIndex bufferLength = CFDataGetLength(data);
 UInt8* buffer = CFAllocatorAllocate(NULL, bufferLength, 0);
 CFDataGetBytes(data, CFRangeMake(0, bufferLength), buffer);
 threadPortName = CFStringCreateWithBytes (NULL, buffer, bufferLength,
kCFStringEncodingASCII, FALSE);
 // You must obtain a remote message port by name.
 messagePort = CFMessagePortCreateRemote(NULL, (CFStringRef)threadPortName);
 
 if (messagePort)
 {
 // Retain and save the thread’s comm port for future reference.
 AddPortToListOfActiveThreads(messagePort);
 // Since the port is retained by the previous function, release
 // it here.
 CFRelease(messagePort);
 }
 // Clean up.
 CFRelease(threadPortName);
 CFAllocatorDeallocate(NULL, buffer);
 }
 else
 {
 // Process other messages.
 }
 return NULL;
}
```

主线程配置好后，剩下的唯一事情是让新创建的工作线程创建自己的端口然后签到。列表 3-19 显示了工作线程的入口函数。函数获取了主线程的端口名并使用它来创建和主线程的远程连接。然后这个函数创建自己的本地端口号，安装到线程的 run loop，最后连同本地端口名称一起发回主线程签到。

Listing 3-19 Setting up the thread structures

``` C
OSStatus ServerThreadEntryPoint(void* param)
{
 // Create the remote port to the main thread.
 CFMessagePortRef mainThreadPort;
 CFStringRef portName = (CFStringRef)param;
 mainThreadPort = CFMessagePortCreateRemote(NULL, portName);
 // Free the string that was passed in param.
 CFRelease(portName);
 // Create a port for the worker thread.
 CFStringRef myPortName = CFStringCreateWithFormat(NULL, NULL,
CFSTR("com.MyApp.Thread-%d"), MPCurrentTaskID());
 // Store the port in this thread’s context info for later reference.
 CFMessagePortContext context = {0, mainThreadPort, NULL, NULL, NULL};
 Boolean shouldFreeInfo;
 Boolean shouldAbort = TRUE;
 
 CFMessagePortRef myPort = CFMessagePortCreateLocal(NULL,
 myPortName,
 &ProcessClientRequest,
 &context,
 &shouldFreeInfo);
 if (shouldFreeInfo)
 {
 // Couldn't create a local port, so kill the thread.
 MPExit(0);
 }
 CFRunLoopSourceRef rlSource = CFMessagePortCreateRunLoopSource(NULL, myPort, 0);
 if (!rlSource)
 {
 // Couldn't create a local port, so kill the thread.
 MPExit(0);
 }
 // Add the source to the current run loop.
 
 CFRunLoopAddSource(CFRunLoopGetCurrent(), rlSource, kCFRunLoopDefaultMode);
 // Once installed, these can be freed.
 CFRelease(myPort);
 CFRelease(rlSource);
 // Package up the port name and send the check-in message.
 CFDataRef returnData = nil;
 CFDataRef outData;
 CFIndex stringLength = CFStringGetLength(myPortName);
 UInt8* buffer = CFAllocatorAllocate(NULL, stringLength, 0);
 
 CFStringGetBytes(myPortName,
 CFRangeMake(0,stringLength),
 kCFStringEncodingASCII,
 0,
 FALSE,
 buffer,
 stringLength,
 NULL);
 outData = CFDataCreate(NULL, buffer, stringLength);
 CFMessagePortSendRequest(mainThreadPort, kCheckinMessage, outData, 0.1, 0.0, NULL,
NULL);
 // Clean up thread data structures.
 CFRelease(outData);
 CFAllocatorDeallocate(NULL, buffer);
 // Enter the run loop.
 CFRunLoopRun();
}
```

一旦线程进入了它的 run loop，所有发送到线程端口的事件都会由 ProcessClientRequest 函数处理。函数的具体实现依赖于线程的工作方式，这里就不举例了。
