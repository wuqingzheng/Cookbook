### 3.4.1 配置 Run loop 的源 - 定义自定义输入源

创建自定义的输入源包括定义以下内容：
* 输入源要处理的信息。
* 使感兴趣的客户端（可理解为其他线程）知道如何和输入源交互的调度例程。
* 处理其他任何客户端（可理解为其他线程）发送请求的例程。
* 使输入源失效的取消例程。

由于你自己创建输入源来处理自定义消息，实际配置是灵活配置的。调度例程，处理例程和取消例程都是你创建自定义输入源时最关键的例程。然而输入源其他的大部分行为都发生在这些例程的外部。比如，由你决定数据传输到输入源的机制，还有输入源和其他线程的通信机制也是由你决定。

Figure3-2 显示了一个自定义输入源的配置的例子。在该例中，程序的主线程维护了输入源的引用，输入源所需的自定义命令缓冲区和输入源所在的 run loop。当主线程有任务需要分发给工作线程时，主线程会给命令缓冲区发送命令和必须的信息来通知工作线程开始执行任务。（因为主线程和输入源所在工作线程都可以访问命令缓冲区，因此这些访问必须是同步的）一旦命令传送出去，主线程会通知输入源并且唤醒工作线程的 run loop。而一收到唤醒命令，run loop 会调用输入源的处理程序，由它来执行命令缓冲区中相应的命令。

<p align=center>Figure 3-2 Operating a custom input source

![](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/Art/custominputsource.jpg)

以下部分解释下上图的实现自定义输入源关键部分和你需要实现的关键代码。

#### 定义输入源
定义自定义的输入源需要使用 Core Foundation 的例程来配置你的 run loop 源并把它添加到 run loop。尽管这些基本的处理例程是基于 C 的函数，但并不排除你可以对这些函数进行封装，并使用 Objective-C 或 Objective-C++来实现你代码的主体。

图 3-2 中的输入源使用了 Objective-C 的对象辅助 run loop 来管理命令缓冲区。列表 3-3 给出了该对象的定义。RunLoopSource 对象管理着命令缓冲区并以此来接收其他线程的消息。例子同样给出了 RunLoopContext 对象的定义，它是一个用于传递 RunLoopSource 对象和 run loop 引用给程序主线程的一个容器。

Listing 3-3 The custom input source object definition

``` Objective-C
@interface RunLoopSource : NSObject
{
 CFRunLoopSourceRef runLoopSource;
 NSMutableArray* commands;
}
- (id)init;
- (void)addToCurrentRunLoop;
- (void)invalidate;
// Handler method
- (void)sourceFired;
// Client interface for registering commands to process
- (void)addCommand:(NSInteger)command withData:(id)data;
- (void)fireAllCommandsOnRunLoop:(CFRunLoopRef)runloop;
@end

// These are the CFRunLoopSourceRef callback functions.
void RunLoopSourceScheduleRoutine (void *info, CFRunLoopRef rl, CFStringRef mode);
void RunLoopSourcePerformRoutine (void *info);
void RunLoopSourceCancelRoutine (void *info, CFRunLoopRef rl, CFStringRef mode);

// RunLoopContext is a container object used during registration of the input source.
@interface RunLoopContext : NSObject
{
 CFRunLoopRef runLoop;
 RunLoopSource* source;
}
@property (readonly) CFRunLoopRef runLoop;
@property (readonly) RunLoopSource* source;
- (id)initWithSource:(RunLoopSource*)src andLoop:(CFRunLoopRef)loop;
@end
```

尽管使用 Objective-C 代码来管理输入源的自定义数据，但是将输入源附加到 run loop 却需要使用基于 C 的回调函数。当你正在把你的 run loop 源附加到 run loop 的时候，使用列表 3-4 中的第一个函数（RunLoopSourceScheduleRoutine）。因为这个输入源只有一个客户端（即主线程），它使用调度函数发送注册信息给应用程序的委托（delegate）。当委托需要和输入源通信时，它会使用 RunLoopContext 对象来完成。

Listing 3-4 Scheduling a run loop source

``` Objective-C
void RunLoopSourceScheduleRoutine (void *info, CFRunLoopRef rl, CFStringRef mode)
{
 RunLoopSource* obj = (RunLoopSource*)info;
 AppDelegate* del = [AppDelegate sharedAppDelegate];
 RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl];
 [del performSelectorOnMainThread:@selector(registerSource:)
 withObject:theContext waitUntilDone:NO];
}
```

一个最重要的回调例程就在输入源被告知时用来处理自定义数据的那个例程。列表 3-5 显示了如何调用这个和 RunLoopSource 对象相关回调例程。这里只是简单的让 RunLoopSource 执行 sourceFired 方法，然后继续处理在命令缓存区出现的命令。

Listing 3-5 Performing work in the input source

``` Objective-C
void RunLoopSourcePerformRoutine (void *info)
{
 RunLoopSource* obj = (RunLoopSource*)info;
 [obj sourceFired];
}
```

如果你使用 CFRunLoopSourceInvalidate 函数把输入源从 run loop 里面移除的话，系统会调用你输入源的取消例程。你可以使用该例程来通知其他客户端该输入源已经失效，客户端应该释放输入源的引用。列表 3-6 显示了由已注册的 RunLoopSource 对取消例程的调用。这个函数将另一个 RunLoopContext 对象发送给应用的委托，当这次是要通知委托释放 run loop 源的引用。

Listing 3-6 Invalidating an input source
d
``` Objective-
void RunLoopSourceCancelRoutine (void *info, CFRunLoopRef rl, CFStringRef mode)
{
 RunLoopSource* obj = (RunLoopSource*)info;
 AppDelegate* del = [AppDelegate sharedAppDelegate];
 RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl];
 [del performSelectorOnMainThread:@selector(removeSource:)
 withObject:theContext waitUntilDone:YES];
}
```

注意:应用委托的 registerSource:和removeSource:方法将在”协调输入源的客户端”部分介绍。

#### 安装输入源到 Run Loop 

列表 3-7 显示了 RunLoopSource 的 init 和 addToCurrentRunLoop 的方法。Init 方法创建 CFRunLoopSourceRef 的不透明类型，该类型必须被附加到 run loop 里面。它把 RunLoopSource 对象做为上下文引用参数，以便回调例程持有该对象的一个引用指针。输入源的安装只在工作线程调用 addToCurrentRunLoop 方法才发生，此时 RunLoopSourceScheduledRoutine 被调用。一旦输入源被添加到 run loop，线程就运行 run loop 并等待事件。

Listing 3-7 Installing the run loop source

``` Objective-C
- (id)init
{
 CFRunLoopSourceContext context = {0, self, NULL, NULL, NULL, NULL, NULL,
 &RunLoopSourceScheduleRoutine,
 RunLoopSourceCancelRoutine,
 RunLoopSourcePerformRoutine};
 runLoopSource = CFRunLoopSourceCreate(NULL, 0, &context);
 commands = [[NSMutableArray alloc] init];
 return self;
}
- (void)addToCurrentRunLoop
{
 CFRunLoopRef runLoop = CFRunLoopGetCurrent();
 CFRunLoopAddSource(runLoop, runLoopSource, kCFRunLoopDefaultMode);
}
```

#### 协调输入源的客户端 

为了让添加的输入源有用，你需要维护它并从其他线程给它发送信号。输入源的主要工作就是将与输入源相关的线程置于休眠状态直到有事件发生。这就意味着程序中的要有其他线程知道该输入源信息并有办法与之通信。

通知客户端关于你输入源信息的方法之一就是当你的输入源开始安装到你的 run loop 上面后发送注册请求。你把输入源注册到任意数量的客户端，或者通过由代理将输入源注册到感兴趣的客户端那。列表 3-8 显示了应用委托定义的注册方法以及它在 RunLoopSource 对象的调度函数被调用时如何运行。该方法接收 RunLoopSource 提供的 RunLoopContext 对象，然后将其添加到它自己的源列表里面。另外，还显示了输入源从 run loop 移除时候的使用来取消注册例程。

Listing 3-8 Registering and removing an input source with the application delegate

``` Objective-C
- (void)registerSource:(RunLoopContext*)sourceInfo;
{
 [sourcesToPing addObject:sourceInfo];
}
- (void)removeSource:(RunLoopContext*)sourceInfo
{
 id objToRemove = nil;
 for (RunLoopContext* context in sourcesToPing)
 {
 if ([context isEqual:sourceInfo])
 {
 objToRemove = context;
 break;
 }
 }
 if (objToRemove)
 [sourcesToPing removeObject:objToRemove];
}
```
注意：该回调函数调用了列表 3-4 和列表 3-6 中描述的方法。

#### 通知输入源 

在客户端发送数据到输入源后，它必须发信号通知源并且唤醒它的 run loop。发送信号给源可以让 run loop 知道该源已经做好处理消息的准备。而且因为信号发送时线程可能处于休眠状态，你必须总是显式的唤醒 run loop。如果不这样做的话会导致延迟处理输入源。

列表 3-9 显示了 RunLoopSource 对象的 fireCommandsOnRunLoop 方法。当客户端准备好处理加入缓冲区的命令后会调用此方法。

Listing 3-9 Waking up the run loop

```
- (void)fireCommandsOnRunLoop:(CFRunLoopRef)runloop
{
 CFRunLoopSourceSignal(runLoopSource);
 CFRunLoopWakeUp(runloop);
}

```

注意：你不应该试图通过自定义输入源处理一个 SIGHUP 或其他进程级别类型的信号。Core Foundation 唤醒 run loop 的函数不是信号安全的，不能在你的应用信号处理例程（signal handler routines）里面使用。关于更多信号处理例程，参阅 sigaction 主页。

