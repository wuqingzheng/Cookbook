## 4.4 线程安全设计的技巧

同步工具是让你代码安全的有用方法，但是它们并非灵丹妙药。与非线程性能相比，使用太多的锁或其他类型的同步原语（**synchronization primitives**）实际上会降低应用程序的线程性能。在性能和安全之间寻找平衡是一门需要经验的艺术。以下各部分提供帮助你为你应用选择合适的同步级别的技巧。

### 4.4.1 完全避免同步

对于你新的项目，甚至已有项目，设计你的代码和数据结构来避免使用同步是一个很好的解决办法。虽然锁和其他类型同步工具很有用，但是它们会影响任何应用的性能。而且如果整体设计导致特定资源的高竞争，你的线程可能需要等待更长时间。实现并发最好的方法是减少你并发任务之间的交互和相互依赖。如果每个任务在它自己的数据集上面操作，那它不需要使用锁来保护这些数据。甚至如果两个任务共享一个普通数据集，你可以查看分区方法，它们设置或提供拷贝每一项任务的方法。当然，拷贝数据集本身也需要成本，所以在你做出决定前，你需要权衡这些成本和使用同步工具造成的成本那个更可以接受。

### 4.4.2 了解同步的限制

同步工具只有当它们被用在应用程序中的所有线程是一致时才是有效的。如果你创建了互斥锁来限制特定资源的访问，你所有线程都必须在试图操纵资源前获得同一互斥锁。如果不这样做导致破坏一个互斥锁提供的保护，这是编程的错误。

### 4.4.3 注意对代码正确性的威胁

当你使用锁和内存屏障时，你应该总是小心的把它们放在你代码正确的地方。即使有条件的锁（似乎很好放置）也可能会让你产生一个虚假的安全感。以下一系列例子试图通过指出看似无害的代码的漏洞来举例说明该问题。其基本前提是你有一个可变的数组，它包含一组不可变的对象集。假设你想要调用数组中第一个对象的方法。你可能会做类似下面那样的代码：

``` Objective-C
NSLock* arrayLock = GetArrayLock();
NSMutableArray* myArray = GetSharedArray();
id anObject;
[arrayLock lock];
anObject = [myArray objectAtIndex:0];
[arrayLock unlock];
[anObject doSomething];
```

因为数组是可变的，所有数组周围的锁防止其他线程修改该数组直到你获得了想要的对象。而且因为对象限制它们本身是不可更改的，所以在调用对象的 `doSomething` 方法周围不需要锁。

但是上面显式的例子有一个问题。如果当你释放该锁，而在你有机会执行 `doSomething` 方法前其他线程到来并从数组中删除所有对象，那会发生什么呢？对于没有使用垃圾回收的应用程序，你代码用户的对象可能已经释放了，让 **anObject** 对象指向一个非法的内存地址。了修正该问题，你可能决定简单的重新安排你的代码，让它在调用 `doSomething` 之后才释放锁，如下所示：

``` Objective-C
NSLock* arrayLock = GetArrayLock();
NSMutableArray* myArray = GetSharedArray();
id anObject;
[arrayLock lock];
anObject = [myArray objectAtIndex:0];
[anObject doSomething];
[arrayLock unlock];
```
通过把 `doSomething` 的调用移到锁的内部，你的代码可以保证该方法被调用的时候该对象还是有效的。不幸的是，如果 `doSomething` 方法需要耗费很长的时间，这有可能导致你的代码保持拥有该锁很长时间，这会产生一个性能瓶颈。

该代码的问题不是关键区域定义不清，而是实际问题是不可理解的。真正的问题是由其他线程引发的内存管理的问题。因为它可以被其他线程释放，最好的解决办法是在释放锁之前 retain anObject。该解决方案涉及对象被释放，并没有引发一个强制的性能损失。

``` Objective-C
NSLock* arrayLock = GetArrayLock();
NSMutableArray* myArray = GetSharedArray();
id anObject;
[arrayLock lock];
anObject = [myArray objectAtIndex:0];
[anObject retain];
[arrayLock unlock];
[anObject doSomething];
[anObject release];
```

尽管前面的例子非常简单，它们说明了非常重要的一点。当它涉及到正确性时，你需要考虑不仅仅是问题的表面。内存管理和其他影响你设计的因子都有可能因为出现多个线程而受到影响，所以你必须考虑从上到下考虑这些问题。此外，你应该在涉及安全的时候假设编译器总是出现最坏的情况。这种意识和警惕性，可以帮你避免潜在的问题，并确保你的代码运行正确。

关于更多介绍如何让你应用程序安全的额外例子，参阅  [Thread Safety Summary](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-SW1)

### 4.4.4 当心死锁（Deadlocks）和活锁(Livelocks)

任何时候线程试图同时获得多于一个锁，都有可能引发潜在的死锁。当两个不同的线程分别保持一个锁（而该锁是另外一个线程需要的）又试图获得另外线程保持的锁时就会发生死锁。结果是每个线程都会进入持久性阻塞状态，因为它永远不可能获得另外那个锁。

一个活锁和死锁类似，当两个线程竞争同一个资源的时候就可能发生活锁。在发生活锁的情况里，一个线程放弃它的第一个锁并试图获得第二个锁。一旦它获得第二个锁，它返回并试图再次获得一个锁。线程就会被锁起来，因为它花费所有的时间来释放一个锁，并试图获取其他锁，而不做实际的工作。避免死锁和活锁的最好方法是同一个时间只拥有一个锁。如果你必须在同一时间获取多于一个锁，你应该确保其他线程没有做类似的事情。

### 4.4.5 正确使用 Volatile 变量

如果你已经使用了一个互斥锁来保护一个代码段，不要自动假设你需要使用关键词 volatile 来保护该代码段的重要的变量。一个互斥锁包含了内存屏障来确保加载和存储操作是按照正确顺序的。在一个临界区添加关键字 volatile 到变量上面会强制每次访问该变量的时候都要从内存里面从加载。这两种同步技巧的组合使用在一些特定区域是必须的，但是同样会导致显著的性能损失。如果单独使用互斥锁已经可以保护变量，那么忽略关键字 volatile。

在你尝试去避免使用互斥锁的时候，不使用 volatile 变量同样也很重要。通常情况下，互斥锁和其他同步机制是比 volatile 变量更好的方式来保护数据结构的完整性。关键字 volatile 只是确保从内存加载变量而不是使用寄存器里面的变量。它不保证你代码访问变量是正确的。









