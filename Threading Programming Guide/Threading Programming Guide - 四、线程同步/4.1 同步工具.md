## 4.1 同步工具

为了防止不同线程意外修改数据，你可以设计你的程序没有同步问题，或你也可以使用同步工具。尽管完全避免出现同步问题相对更好一点，但是几乎总是无法实现。以下个部分介绍了你可以使用的同步工具的基本类别。

### 4.1.1 原子操作

原子操作是同步的一个简单的形式，它处理简单的数据类型。原子操作的优势是它们不妨碍竞争的线程。对于简单的操作，比如递增一个计数器，原子操作比使用锁具有更高的性能优势。

Mac OS X 和 iOS 包含了许多在 32 位和 64 位执行基本的数学和逻辑运算的操作。这些操作都使用了原子版本来操作比较和交换，测试和设置，测试和清理等。查看支持原子操作的列表，参阅/user/include/libkern/OSAtomic.h 头文件和参见 atomic 主页。


### 4.1.2 内存屏障和 Volatile 变量

为了达到最佳性能，编译器通常会对汇编基本的指令进行重新排序来尽可能保持处理器的指令流水线。作为优化的一部分，编译器有可能对访问主内存的指令，如果它认为这有可能产生不正确的数据时，将会对指令进行重新排序。不幸的是，靠编译器检测到所有可能内存依赖的操作几乎总是不太可能的。如果看似独立的变量实际上是相互影响，那么编译器优化有可能把这些变量更新位错误的顺序，导致潜在不正确结果。

内存屏障（memory barrier）是一个使用来确保内存操作按照正确的顺序工作的非阻塞的同步工具。内存屏障的作用就像一个栅栏，迫使处理器来完成位于障碍前面的任何加载和存储操作，才允许它执行位于屏障之后的加载和存储操作。内存屏障同样使用来确保一个线程（但对另外一个线程可见）的内存操作总是按照预定的顺序完成。如果在这些地方缺少内存屏障有可能让其他线程看到看似不可能的结果（比如，内存屏障的维基百科条目）。为了使用一个内存屏障，你只要在你代码里面需要的地方简单的调用 OSMemoryBarrier 函数。

**Volatile** 变量适用于独立变量的另一个内存限制类型。编译器优化代码通过加载这些变量的值进入寄存器。对于本地变量，这通常不会有什么问题。但是如果一个变量对另外一个线程可见，那么这种优化可能会阻止其他线程发现变量的任何变化。在变量之前加上关键字 **volatile** 可以强制编译器每次使用变量的时候都从内存里面加载。如果一个变量的值随时可能被编译器无法检测的外部源更改，那么你可以把该变量声明为 volatile 变量。

因为内存屏障和 volatile 变量降低了编译器可执行的优化，因此你应该谨慎使用它们，只在有需要的地方时候，以确保正确性。关于更多使用内存屏障的信息，参阅 OSMemoryBarrier 主页。


### 4.1.3 锁
锁是最常用的同步工具之一。 您可以使用锁来保护代码的关键部分（critical section），这些代码段在同一个时间只能允许被一个线程访问。 例如，关键部分可能会操纵特定的数据结构或使用一次最多支持一个客户端的资源。 通过在本节中放置一个锁，可以排除其他线程进行可能影响代码正确性的更改。

表4-1列出了程序员常用的一些锁。 OS X和iOS为大多数这些锁类型提供实现，但不是全部。 对于不受支持的锁类型，说明列解释了为什么这些锁没有直接在平台上实现的原因

Table 4-1 Lock types

Lock | Description
：



注意：大部分锁类型都合并了内存屏障（memory barrier）来确保在进入关键代码之前它前面的加载和存储指令都已经完成。 关于如何使用锁的信息，参阅[使用锁](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW16)部分。

### 4.1.4 条件(Conditions)

条件是另外一个形式的信号量(semaphore)，它允许线程在特定条件为真时互相发信号。条件通常被用来说明资源可用性或用来确保任务以特定的顺序执行。当一个线程测试一个条件时，它会被阻塞直到条件为真。它会一直阻塞直到其他线程显式的修改信号量的状态。条件和互斥锁(mutex lock)的区别在于多个线程被允许同时访问一个条件。条件更多是允许不同线程根据一些指定的标准通过的守门人。

一种方式是你使用条件来管理挂起事件的池。事件队列可能使用条件变量来给等待线程发送信号，此时它们在事件队列中的时候。如果一个事件到达时，队列将给条件发送合适信号。如果一个线程已经处于等待，它会被唤醒，届时它将会取出事件并处理它。如果两个事件到达队列的时间大致相同，队列将会发送两次信号唤醒两个线程。

系统通过几个不同的技术来支持条件。然而正确实现条件需要仔细编写代码，因此你应该在你自己代码中使用条件之前查看”使用条件”部分的例子。

### 4.1.5 执行 Selector 例程

Cocoa 程序有一种方便的方式将消息以同步方式传递给单个线程。NSObject类声明了在应用程序的一个活动线程上执行 selector 的方法。这些方法允许线程异步传递消息，并确保它们将由目标线程同步执行。比如，可以使用 perform selector messages 将分布式计算的结果传递到应用程序的主线程或指定的协调器线程。 每个执行 selector 的请求都会被放入一个目标线程的 run loop 的队列里面，然后按接收到的顺序按顺序处理请求。。关于执行 selector 例程的总结和更多关于如何使用它们的信息，参阅 [Cocoa Perform Selector Sources](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW44)。

