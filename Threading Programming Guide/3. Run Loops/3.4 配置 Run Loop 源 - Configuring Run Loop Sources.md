## 3.4 配置 Run Loop 源 - Configuring Run Loop Sources
以下部分显示了如何在 Cocoa 和 Core Foundation 中设置不同类型的输入源的示例。


### 3.4.1 配置 Run loop 的源 - 定义自定义输入源
创建自定义的输入源包括定义以下内容：
* 输入源要处理的信息。
* 使感兴趣的客户端（可理解为其他线程）知道如何和输入源交互的调度例程。
* 处理其他任何客户端（可理解为其他线程）发送请求的例程。
* 使输入源失效的取消例程。

由于你自己创建输入源来处理自定义消息，实际配置是灵活配置的。调度例程，处理例程和取消例程都是你创建自定义输入源时最关键的例程。然而输入源其他的大部分行为都发生在这些例程的外部。比如，由你决定数据传输到输入源的机制，还有输入源和其他线程的通信机制也是由你决定。

Figure3-2 显示了一个自定义输入源的配置的例子。在该例中，程序的主线程维护了输入源的引用，输入源所需的自定义命令缓冲区和输入源所在的 run loop。当主线程有任务需要分发给工作线程时，主线程会给命令缓冲区发送命令和必须的信息来通知工作线程开始执行任务。（因为主线程和输入源所在工作线程都可以访问命令缓冲区，因此这些访问必须是同步的）一旦命令传送出去，主线程会通知输入源并且唤醒工作线程的 run loop。而一收到唤醒命令，run loop 会调用输入源的处理程序，由它来执行命令缓冲区中相应的命令。

Figure 3-2 Operating a custom input source

![](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/Art/custominputsource.jpg)

以下部分解释下上图的实现自定义输入源关键部分和你需要实现的关键代码。

#### 定义输入源
定义自定义的输入源需要使用 Core Foundation 的例程来配置你的 run loop 源并把它添加到 run loop。尽管这些基本的处理例程是基于 C 的函数，但并不排除你可以对这些函数进行封装，并使用 Objective-C 或 Objective-C++来实现你代码的主体。

图 3-2 中的输入源使用了 Objective-C 的对象辅助 run loop 来管理命令缓冲区。列表 3-3 给出了该对象的定义。RunLoopSource 对象管理着命令缓冲区并以此来接收其他线程的消息。例子同样给出了 RunLoopContext 对象的定义，它是一个用于传递 RunLoopSource 对象和 run loop 引用给程序主线程的一个容器。

Listing 3-3 The custom input source object definition

``` Objective-C
@interface RunLoopSource : NSObject
{
 CFRunLoopSourceRef runLoopSource;
 NSMutableArray* commands;
}
- (id)init;
- (void)addToCurrentRunLoop;
- (void)invalidate;
// Handler method
- (void)sourceFired;
// Client interface for registering commands to process
- (void)addCommand:(NSInteger)command withData:(id)data;
- (void)fireAllCommandsOnRunLoop:(CFRunLoopRef)runloop;
@end

// These are the CFRunLoopSourceRef callback functions.
void RunLoopSourceScheduleRoutine (void *info, CFRunLoopRef rl, CFStringRef mode);
void RunLoopSourcePerformRoutine (void *info);
void RunLoopSourceCancelRoutine (void *info, CFRunLoopRef rl, CFStringRef mode);

// RunLoopContext is a container object used during registration of the input source.
@interface RunLoopContext : NSObject
{
 CFRunLoopRef runLoop;
 RunLoopSource* source;
}
@property (readonly) CFRunLoopRef runLoop;
@property (readonly) RunLoopSource* source;
- (id)initWithSource:(RunLoopSource*)src andLoop:(CFRunLoopRef)loop;
@end
```

尽管使用 Objective-C 代码来管理输入源的自定义数据，但是将输入源附加到 run loop 却需要使用基于 C 的回调函数。当你正在把你的 run loop 源附加到 run loop 的时候，使用列表 3-4 中的第一个函数（RunLoopSourceScheduleRoutine）。因为这个输入源只有一个客户端（即主线程），它使用调度函数发送注册信息给应用程序的委托（delegate）。当委托需要和输入源通信时，它会使用 RunLoopContext 对象来完成。

Listing 3-4 Scheduling a run loop source

``` Objective-C
void RunLoopSourceScheduleRoutine (void *info, CFRunLoopRef rl, CFStringRef mode)
{
 RunLoopSource* obj = (RunLoopSource*)info;
 AppDelegate* del = [AppDelegate sharedAppDelegate];
 RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl];
 [del performSelectorOnMainThread:@selector(registerSource:)
 withObject:theContext waitUntilDone:NO];
}
```

一个最重要的回调例程就在输入源被告知时用来处理自定义数据的那个例程。列表 3-5 显示了如何调用这个和 RunLoopSource 对象相关回调例程。这里只是简单的让 RunLoopSource 执行 sourceFired 方法，然后继续处理在命令缓存区出现的命令。

Listing 3-5 Performing work in the input source

``` Objective-C
void RunLoopSourcePerformRoutine (void *info)
{
 RunLoopSource* obj = (RunLoopSource*)info;
 [obj sourceFired];
}
```

如果你使用 CFRunLoopSourceInvalidate 函数把输入源从 run loop 里面移除的话，系统会调用你输入源的取消例程。你可以使用该例程来通知其他客户端该输入源已经失效，客户端应该释放输入源的引用。列表 3-6 显示了由已注册的 RunLoopSource 对取消例程的调用。这个函数将另一个 RunLoopContext 对象发送给应用的委托，当这次是要通知委托释放 run loop 源的引用。

Listing 3-6 Invalidating an input source
d
``` Objective-
void RunLoopSourceCancelRoutine (void *info, CFRunLoopRef rl, CFStringRef mode)
{
 RunLoopSource* obj = (RunLoopSource*)info;
 AppDelegate* del = [AppDelegate sharedAppDelegate];
 RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl];
 [del performSelectorOnMainThread:@selector(removeSource:)
 withObject:theContext waitUntilDone:YES];
}
```

注意:应用委托的 registerSource:和removeSource:方法将在”协调输入源的客户端”部分介绍。

#### 安装输入源到 Run Loop 

列表 3-7 显示了 RunLoopSource 的 init 和 addToCurrentRunLoop 的方法。Init 方法创建 CFRunLoopSourceRef 的不透明类型，该类型必须被附加到 run loop 里面。它把 RunLoopSource 对象做为上下文引用参数，以便回调例程持有该对象的一个引用指针。输入源的安装只在工作线程调用 addToCurrentRunLoop 方法才发生，此时 RunLoopSourceScheduledRoutine 被调用。一旦输入源被添加到 run loop，线程就运行 run loop 并等待事件。

Listing 3-7 Installing the run loop source

``` Objective-C
- (id)init
{
 CFRunLoopSourceContext context = {0, self, NULL, NULL, NULL, NULL, NULL,
 &RunLoopSourceScheduleRoutine,
 RunLoopSourceCancelRoutine,
 RunLoopSourcePerformRoutine};
 runLoopSource = CFRunLoopSourceCreate(NULL, 0, &context);
 commands = [[NSMutableArray alloc] init];
 return self;
}
- (void)addToCurrentRunLoop
{
 CFRunLoopRef runLoop = CFRunLoopGetCurrent();
 CFRunLoopAddSource(runLoop, runLoopSource, kCFRunLoopDefaultMode);
}
```

#### 协调输入源的客户端 

为了让添加的输入源有用，你需要维护它并从其他线程给它发送信号。输入源的主要工作就是将与输入源相关的线程置于休眠状态直到有事件发生。这就意味着程序中的要有其他线程知道该输入源信息并有办法与之通信。

通知客户端关于你输入源信息的方法之一就是当你的输入源开始安装到你的 run loop 上面后发送注册请求。你把输入源注册到任意数量的客户端，或者通过由代理将输入源注册到感兴趣的客户端那。列表 3-8 显示了应用委托定义的注册方法以及它在 RunLoopSource 对象的调度函数被调用时如何运行。该方法接收 RunLoopSource 提供的 RunLoopContext 对象，然后将其添加到它自己的源列表里面。另外，还显示了输入源从 run loop 移除时候的使用来取消注册例程。

Listing 3-8 Registering and removing an input source with the application delegate

``` Objective-C
- (void)registerSource:(RunLoopContext*)sourceInfo;
{
 [sourcesToPing addObject:sourceInfo];
}
- (void)removeSource:(RunLoopContext*)sourceInfo
{
 id objToRemove = nil;
 for (RunLoopContext* context in sourcesToPing)
 {
 if ([context isEqual:sourceInfo])
 {
 objToRemove = context;
 break;
 }
 }
 if (objToRemove)
 [sourcesToPing removeObject:objToRemove];
}
```
注意：该回调函数调用了列表 3-4 和列表 3-6 中描述的方法。

#### 通知输入源 

在客户端发送数据到输入源后，它必须发信号通知源并且唤醒它的 run loop。发送信号给源可以让 run loop 知道该源已经做好处理消息的准备。而且因为信号发送时线程可能处于休眠状态，你必须总是显式的唤醒 run loop。如果不这样做的话会导致延迟处理输入源。

列表 3-9 显示了 RunLoopSource 对象的 fireCommandsOnRunLoop 方法。当客户端准备好处理加入缓冲区的命令后会调用此方法。

Listing 3-9 Waking up the run loop

```
- (void)fireCommandsOnRunLoop:(CFRunLoopRef)runloop
{
 CFRunLoopSourceSignal(runLoopSource);
 CFRunLoopWakeUp(runloop);
}

```

注意：你不应该试图通过自定义输入源处理一个 SIGHUP 或其他进程级别类型的信号。Core Foundation 唤醒 run loop 的函数不是信号安全的，不能在你的应用信号处理例程（signal handler routines）里面使用。关于更多信号处理例程，参阅 sigaction 主页。

### 3.4.2 配置 Run loop 的源 - 配置定时源

创建一个定时源，你所需要做的只是创建一个定时器对象并把它调度到你的 **run loop**。**Cocoa** 程序中使用 **NSTimer** 类来创建一个新的定时器对象，而 **Core Foundation** 中使用 **CFRunLoopTimerRef** 不透明类型。本质上，**NSTimer** 类是 **Core Foundation** 的简单扩展，它提供了便利的特征，例如能使用相同的方法创建和调配定时器。

**Cocoa** 中可以使用以下 **NSTimer** 类方法来创建并调配一个定时器：
* scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:
* scheduledTimerWithTimeInterval:invocation:repeats:

上述方法创建了定时器并以默认模式把它们添加到当前线程的 **run loop**。你可以手动创建 **NSTimer** 对象，并通过 **NSRunLoop** 的 `addTimer:forMode:` 把它添加到 **run loop**。两种方法都做了相同的事，区别在于你对定时器配置的控制权。例如，如果你手工创建定时器并把它添加到 **run loop**，你可以选择要添加的模式而不使用默认模式。

Listing 3-10 显示了如何使用这这两种方法创建定时器。第一个定时器在初始化后 **1** 秒开始运行，此后每隔 **0.1** 秒运行。第二个定时器则在初始化后 **0.2** 秒开始运行，此后每隔 **0.2** 秒运行。

<p align = center>Listing 3-10 Creating and scheduling timers using NSTimer

``` Objective-C
NSRunLoop* myRunLoop = [NSRunLoop currentRunLoop];

// Create and schedule the first timer.
NSDate* futureDate = [NSDate dateWithTimeIntervalSinceNow:1.0];
NSTimer* myTimer = [[NSTimer alloc] initWithFireDate:futureDate
                                            interval:0.1
                                              target:self
                                            selector:@selector(myDoFireTimer1:)
                                            userInfo:nil
                                             repeats:YES];
[myRunLoop addTimer:myTimer forMode:NSDefaultRunLoopMode];

// Create and schedule the second timer.
[NSTimer scheduledTimerWithTimeInterval:0.2
                                 target:self
                               selector:@selector(myDoFireTimer2:)
                               userInfo:nil
                                repeats:YES];
```


Listing 3-11 显示了使用 **Core Foundation** 函数来配置定时器的代码。尽管这个例子中并没有把任何用户定义的信息作为上下文结构，但是你可以使用这个上下文结构传递任何你想传递的信息给定时器。关于该上下文结构的内容的详细信息，参阅 [CFRunLoopTimer Reference](https://developer.apple.com/documentation/corefoundation/cfrunlooptimer-rhk)。

Listing 3-11 Creating and scheduling a timer using Core Foundation

``` Objective-C
CFRunLoopRef runLoop = CFRunLoopGetCurrent();
CFRunLoopTimerContext context = {0, NULL, NULL, NULL, NULL};
CFRunLoopTimerRef timer = CFRunLoopTimerCreate(kCFAllocatorDefault, 0.1, 0.3, 0, 0,&myCFTimerCallback, &context);
CFRunLoopAddTimer(runLoop, timer, kCFRunLoopCommonModes);
```

### 3.4.3 配置 Run loop 的源 - 配置基于端口的输入源

**Cocoa** 和 **Core Foundation** 都提供了基于端口的对象用于线程或进程间的通信。以下部分显示如何使用几种不同类型的端口对象建立端口通信。

#### 配置 NSMachPort 对象 

为了和 **NSMachPort 对象** 建立稳定的本地连接，你需要创建端口对象并将之加入相应的线程的 run loop。当运行辅助线程的时候，你传递端口对象到线程的主体入口点。辅助线程可以使用相同的端口对象将消息返回给原线程。

##### a. 实现主线程的代码 

列表 3-12 显示了加载辅助线程的主线程代码。因为 **Cocoa** 框架执行许多配置端口及 **run loop** 相关的步骤，所以 lauchThread 方法比相应的 Core Foundation 版本（列表 3-17）要明显简短。然而两种方法的本质几乎是一样的，唯一的区别就是在 Cocoa 中直接发送 NSPort 对象，而不是发送本地端口名称。

Listing 3-12 Main thread launch method

``` Objective-C
- (void)launchThread
{
 NSPort* myPort = [NSMachPort port];
 if (myPort)
 {
 // This class handles incoming port messages.
 [myPort setDelegate:self];
 
 // Install the port as an input source on the current run loop.
 [[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRunLoopMode];
 
 // Detach the thread. Let the worker release the port.
 [NSThread detachNewThreadSelector:@selector(LaunchThreadWithPort:)
 toTarget:[MyWorkerClass class] withObject:myPort];
 }
}
```

为了在你的线程间建立双向的通信，你需要让你的工作线程在签到的消息中发送自己的本地端口到主线程。主线程接收到签到消息后就可以知道辅助线程运行正常，并且提供了发送消息给辅助线程的方法。

列表 3-13 显示了主要线程的 handlePortMessage：方法。当由数据到达线程的本地端口时，该方法被调用。当签到消息到达时，此方法可以直接从辅助线程里面检索端口并保存下来以备后续使用。

Listing 3-13 Handling Mach port messages

``` Objective-C
#define kCheckinMessage 100
// Handle responses from the worker thread.
- (void)handlePortMessage:(NSPortMessage *)portMessage
{
 unsigned int message = [portMessage msgid];
 NSPort* distantPort = nil;
 if (message == kCheckinMessage)
 {
 // Get the worker thread’s communications port.
 distantPort = [portMessage sendPort];
 // Retain and save the worker port for later use.
 [self storeDistantPort:distantPort];
 }
 else
 {
 // Handle other messages.
 }
 }
```

##### b. 辅助线程的实现代码

对于辅助工作线程，你必须配置线程使用特定的端口以发送消息返回给主要线程。

列表 3-14 显示了如何设置工作线程的代码。创建了线程的自动释放池后，紧接着创建工作对象驱动线程运行。工作对象的 sendCheckinMessage：方法（如列表 3-15 所示）创建了工作线程的本地端口并发送签到消息回主线程。

Listing 3-14 Launching the worker thread using Mach ports

``` Objective-C
+(void)LaunchThreadWithPort:(id)inData
{
 NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
 
 // Set up the connection between this thread and the main thread.
 NSPort* distantPort = (NSPort*)inData;
 MyWorkerClass* workerObj = [[self alloc] init];
 [workerObj sendCheckinMessage:distantPort];
 [distantPort release];
 // Let the run loop process things.
 do
 {
 [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode
 beforeDate:[NSDate distantFuture]];
 }
 while (![workerObj shouldExit]);
 [workerObj release];
 [pool release];
}
```

当使用 NSMachPort 时候，本地和远程线程可以使用相同的端口对象在线程间进行单边通信。换句话说，一个线程创建的本地端口对象成为另一个线程的远程端口对象。

列表 3-15 显示了辅助线程的签到例程，该方法为之后的通信设置自己的本地端口，然后发送签到消息给主线程。它使用 LaunchThreadWithPort：方法中收到的端口对象做为目标消息。

Listing 3-15 Sending the check-in message using Mach ports

``` Objective-C
// Worker thread check-in method
- (void)sendCheckinMessage:(NSPort*)outPort
{
 // Retain and save the remote port for future use.
 [self setRemotePort:outPort];
 
 // Create and configure the worker thread port.
 NSPort* myPort = [NSMachPort port];
 [myPort setDelegate:self];
 [[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRunLoopMode];
 // Create the check-in message.
 NSPortMessage* messageObj = [[NSPortMessage alloc] initWithSendPort:outPort
 receivePort:myPort components:nil];
 if (messageObj)
 {
 // Finish configuring the message and send it immediately.
 [messageObj setMsgId:setMsgid:kCheckinMessage];
 [messageObj sendBeforeDate:[NSDate date]];
 }
}
```

#### 配置 NSMessagePort 对象 

为了和 NSMeaasgePort 的建立稳定的本地连接，你不能简单的在线程间传递端口对象。远程消息端口必须通过名字来获得。在 Cocoa 中这需要你给本地端口指定一个名字，并将名字传递到远程线程以便远程线程可以获得合适的端口对象用于通信。列表 3-16 显示端口创建，注册到你想要使用消息端口的进程。

Listing 3-16 Registering a message port

``` Objective-C
NSPort* localPort = [[NSMessagePort alloc] init];
// Configure the object and add it to the current run loop.
[localPort setDelegate:self];
[[NSRunLoop currentRunLoop] addPort:localPort forMode:NSDefaultRunLoopMode];
// Register the port using a specific name. The name must be unique.
NSString* localPortName = [NSString stringWithFormat:@"MyPortName"];
[[NSMessagePortNameServer sharedInstance] registerPort:localPort
 name:localPortName];
```

#### 在 Core Foundation 中配置基于端口的源 

这部分介绍了在 Core Foundation 中如何在程序主线程和工作线程间建立双通道通信。

列 表 3-17 显示了程序主线程加载工作线程的代码。第一步是设置 CFMessagePortRef 不透明类型来监听工作线程的消息。工作线程需要端口的名称来建立连接，以便使字符串传递给工作线程的主入口函数。在当前的用户上下文中端口名必须是唯一的，否则可能在运行时造成冲突。

Listing 3-17 Attaching a Core Foundation message port to a new thread

``` C
#define kThreadStackSize (8 *4096)
OSStatus MySpawnThread()
{
 // Create a local port for receiving responses.
 CFStringRef myPortName;
 CFMessagePortRef myPort;
 CFRunLoopSourceRef rlSource;
 CFMessagePortContext context = {0, NULL, NULL, NULL, NULL};
 Boolean shouldFreeInfo;
 // Create a string with the port name.
 myPortName = CFStringCreateWithFormat(NULL, NULL, CFSTR("com.myapp.MainThread"));
 // Create the port.
 myPort = CFMessagePortCreateLocal(NULL,
 myPortName,
 &MainThreadResponseHandler,
 &context,
 &shouldFreeInfo);
 if (myPort != NULL)
 {
 // The port was successfully created.
 // Now create a run loop source for it.
 rlSource = CFMessagePortCreateRunLoopSource(NULL, myPort, 0);
 if (rlSource)
 {
 // Add the source to the current run loop.
 CFRunLoopAddSource(CFRunLoopGetCurrent(), rlSource, kCFRunLoopDefaultMode);
 // Once installed, these can be freed.
 CFRelease(myPort);
 CFRelease(rlSource);
 }
 }
 // Create the thread and continue processing.
 MPTaskID taskID;
 return(MPCreateTask(&ServerThreadEntryPoint,
 (void*)myPortName,
 kThreadStackSize,
 NULL,
 NULL,
 NULL,
 0,
 &taskID));
}
 
 ```

端口建立而且线程启动后，主线程在等待线程签到时可以继续执行。当签到消息到达后，主线程使用 MainThreadResponseHandler 来分发消息，如列表 3-18 所示。这个函数提取工作线程的端口名，并创建用于未来通信的管道。

Listing 3-18 Receiving the checkin message

``` C
#define kCheckinMessage 100
// Main thread port message handler
CFDataRef MainThreadResponseHandler(CFMessagePortRef local,
 SInt32 msgid,
 CFDataRef data,
 void* info)
{
 if (msgid == kCheckinMessage)
 {
 CFMessagePortRef messagePort;
 CFStringRef threadPortName;
 CFIndex bufferLength = CFDataGetLength(data);
 UInt8* buffer = CFAllocatorAllocate(NULL, bufferLength, 0);
 CFDataGetBytes(data, CFRangeMake(0, bufferLength), buffer);
 threadPortName = CFStringCreateWithBytes (NULL, buffer, bufferLength,
kCFStringEncodingASCII, FALSE);
 // You must obtain a remote message port by name.
 messagePort = CFMessagePortCreateRemote(NULL, (CFStringRef)threadPortName);
 
 if (messagePort)
 {
 // Retain and save the thread’s comm port for future reference.
 AddPortToListOfActiveThreads(messagePort);
 // Since the port is retained by the previous function, release
 // it here.
 CFRelease(messagePort);
 }
 // Clean up.
 CFRelease(threadPortName);
 CFAllocatorDeallocate(NULL, buffer);
 }
 else
 {
 // Process other messages.
 }
 return NULL;
}
```

主线程配置好后，剩下的唯一事情是让新创建的工作线程创建自己的端口然后签到。列表 3-19 显示了工作线程的入口函数。函数获取了主线程的端口名并使用它来创建和主线程的远程连接。然后这个函数创建自己的本地端口号，安装到线程的 run loop，最后连同本地端口名称一起发回主线程签到。

Listing 3-19 Setting up the thread structures

``` C
OSStatus ServerThreadEntryPoint(void* param)
{
 // Create the remote port to the main thread.
 CFMessagePortRef mainThreadPort;
 CFStringRef portName = (CFStringRef)param;
 mainThreadPort = CFMessagePortCreateRemote(NULL, portName);
 // Free the string that was passed in param.
 CFRelease(portName);
 // Create a port for the worker thread.
 CFStringRef myPortName = CFStringCreateWithFormat(NULL, NULL,
CFSTR("com.MyApp.Thread-%d"), MPCurrentTaskID());
 // Store the port in this thread’s context info for later reference.
 CFMessagePortContext context = {0, mainThreadPort, NULL, NULL, NULL};
 Boolean shouldFreeInfo;
 Boolean shouldAbort = TRUE;
 
 CFMessagePortRef myPort = CFMessagePortCreateLocal(NULL,
 myPortName,
 &ProcessClientRequest,
 &context,
 &shouldFreeInfo);
 if (shouldFreeInfo)
 {
 // Couldn't create a local port, so kill the thread.
 MPExit(0);
 }
 CFRunLoopSourceRef rlSource = CFMessagePortCreateRunLoopSource(NULL, myPort, 0);
 if (!rlSource)
 {
 // Couldn't create a local port, so kill the thread.
 MPExit(0);
 }
 // Add the source to the current run loop.
 
 CFRunLoopAddSource(CFRunLoopGetCurrent(), rlSource, kCFRunLoopDefaultMode);
 // Once installed, these can be freed.
 CFRelease(myPort);
 CFRelease(rlSource);
 // Package up the port name and send the check-in message.
 CFDataRef returnData = nil;
 CFDataRef outData;
 CFIndex stringLength = CFStringGetLength(myPortName);
 UInt8* buffer = CFAllocatorAllocate(NULL, stringLength, 0);
 
 CFStringGetBytes(myPortName,
 CFRangeMake(0,stringLength),
 kCFStringEncodingASCII,
 0,
 FALSE,
 buffer,
 stringLength,
 NULL);
 outData = CFDataCreate(NULL, buffer, stringLength);
 CFMessagePortSendRequest(mainThreadPort, kCheckinMessage, outData, 0.1, 0.0, NULL,
NULL);
 // Clean up thread data structures.
 CFRelease(outData);
 CFAllocatorDeallocate(NULL, buffer);
 // Enter the run loop.
 CFRunLoopRun();
}
```

一旦线程进入了它的 run loop，所有发送到线程端口的事件都会由 ProcessClientRequest 函数处理。函数的具体实现依赖于线程的工作方式，这里就不举例了。