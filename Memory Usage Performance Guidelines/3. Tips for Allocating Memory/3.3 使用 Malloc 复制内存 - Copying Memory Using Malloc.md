## 3.3 使用 Malloc 复制内存 - Copying Memory Using Malloc
在 **OS X** 中复制内存有两种主要方法：**直接**（direct）和 **延迟**（delayed）。对于大多数情况，直接方法提供了最佳的整体性能。但是，有时使用延迟复制操作有其好处。 以下部分的目标是向您介绍复制内存的不同方法以及您可能会使用这些方法的情况。

### 3.3.1 直接复制内存 - Copying Memory Directly
直接复制内存涉及使用例如 `memcpy` 或 `memmove` 的例程将字节从一个块复制到另一个块。在复制时，源块（source blocks）和目标块（destination blocks）必须驻留在内存中。但是，这些例程特别适用于以下情况：

* 您要复制的块的很小（小于 16KB）
* 您打算立即使用源块或目标块
* 源块或目标块不是页面对齐的
* 源块和目标块重叠

如果您不打算一段时间使用源数据或目标数据，执行直接复制大内存块会减少性能。直接复制内存会增加应用程序工作集（working set）的大小。无论何时增加应用程序的工作集，都会增加分页到磁盘的机会。 如果在工作集中有两个大内存块的直接副本，则最终可能会将它们分页到磁盘。当您稍后访问源或目标时，您需要从磁盘加载该数据，这比使用 `vm_copy` 执行延迟复制操作要昂贵得多。

> 注意：如果源块和目标块重叠，则应该优先使用 `memmove` 而不是 `memcpy`。`memmove` 的实现在 **OS X** 中正确处理重叠块，但不保证 `memcpy` 的实现。

### 3.3.2 延迟内存复制操作 - Delaying Memory Copy Operations
如果您打算复制许多页面的内存，但不打算立即使用源页面或目标页面，则可能需要使用 `vm_copy` 函数来完成此操作。与 `memmove` 或 `memcpy` 不同，`vm_copy` 不会触及任何实际的内存。它修改虚拟内存映射来表明目标地址范围是源地址范围的写时复制（copy-on-write ）版本。

在特定情况下，`vm_copy` 例程比 `memcpy` 更高效。具体而言，在代码在复制操作后的相当长一段时间内无法访问源或目标内存的情况下，效率更高。`vm_copy` 对延迟使用高效的原因是内核处理 **copy-on-write** 情况。为了执行 **copy** 操作，内核必须从虚拟内存系统中删除对源页面的所有引用。下一次进程访问该源页面上的数据时，会发生软故障，并且内核将该页面作为 **copy-on-write** 页面映射回进程空间。处理单个软错误的过程几乎与直接复制数据一样昂贵。

### 3.3.3 复制少量数据 - Copying Small Amounts of Data
如果您需要复制一小块非重叠数据，则应该比其他任何例程更喜欢使用 `memcpy`。对于小块内存，**GCC 编译器**可以通过用内联指令替换它来优化此例程以按值复制数据。编译器可能不会优化其他例程，如 `memmove` 或 `BlockMoveData`。

### 3.3.4 将数据复制到视频 RAM - Copying Data to Video RAM
将数据复制到 **VRAM** 时，请使用 `BlockMoveDataUncached` 函数，而不是 `bcopy` 等函数。`bcopy` 函数使用可能导致异常错误的缓存操作指令。内核必须修复这些错误才能继续下去，这会极大地降低性能。
