### 4.1 缓存概述 - Overview of Caching
**缓存**是可以极大地提高应用程序性能的对象或数据的集合。

#### 4.1.1 为什么使用缓存？- Why Use Caching?
开发人员使用缓存来存储频繁访问的对象，而这些对象的计算可能很昂贵。重用这些对象可以提供性能优势，因为它们的值不必重新计算。但是，这些对象对应用程序并不重要，如果内存不足，可以将其丢弃。如果被丢弃，它们的值必须在需要时重新计算。

#### 4.1.2 缓存可能导致的问题 - Problems Caching Can Cause
虽然缓存可以在性能方面提供巨大的好处，但缓存也可能存在一些缺陷。最重要的是，缓存可以使用大量的内存。当缓存许多大型数据对象时，很有可能因为缓存很多对象，导致其他应用程序没有剩余的 **RAM**，并且计算机会将所有这些数据写入磁盘以释放 **RAM**，导致应用程序慢慢停止。

#### 4.1.3 解决方案 - Solutions
**Cocoa** 提供了一个 **NSCache** 对象作为你想要缓存的项目的方便存储容器，同时解决了上面讨论的内存管理问题。  **NSCache** 类与 **NSDictionary** 类非常相似，因为它们都包含键值对。然而，一个 **NSCache** 对象是一个“被动缓存”。也就是说，当内存可用时，它积极地缓存它给出的所有数据。然而，当内存不足时，它会自动丢弃其中的一些元素，以为其他应用程序释放内存。稍后，如果需要那些丢弃的项目，则必须重新计算它们的值。

**NSCache** 提供了另外两个有用的“限制”功能：限制缓存元素的数量和限制缓存中所有元素的总成本。要限制缓存允许的元素数量，请调用方法 `setCountLimit:`。例如，如果尝试将 **11** 个项目添加到 `countLimit` 设置为 **10** 的缓存中，缓存可能会自动丢弃其中一个元素。

将项目添加到缓存时，可以指定与每个键值对相关联的 `cost` 值。调用 `setTotalCostLimit：` 方法来设置所有缓存对象成本总和的最大值。因此，当添加一个将 `totalCost` 推到`totalCostLimit` 之上的对象时，缓存可以自动驱逐它的一些对象，以便回到阈值以下。这种驱逐过程不能得到保证，因此试图操纵 `cost ` 值以实现特定行为可能会对缓存的性能造成不利影响。如果没有任何用处，则 `cost` 传入 **0**  或使用 `setObject：forKey:` 方法，该方法不需要传入 `cost`。

>注意：计数限制和总成本限制未严格执行。也就是说，当缓存超过其中一个限制时，它的一些对象可能会立即、以后或永远都不会被移除，这些全部取决于缓存的实现细节。