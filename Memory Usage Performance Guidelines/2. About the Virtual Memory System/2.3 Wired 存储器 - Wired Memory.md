## 2.3 Wired 存储器 - Wired Memory
**Wired memory**（也称为 resident memory）存储的内核代码和数据结构绝不能被分页到磁盘。 **Applications**、**frameworks** 和其他用户级别软件无法分配 **wired memory**。 但是，它们可以随时影响 **wired memory** 存在的数量。 例如，创建线程和端口的应用程序会为与其关联的所需内核资源隐式分配  **wired memory**。

表 2 列出了应用程序生成实体的一些 **wired-memory** 成本。

Table 2  Wired memory generated by user-level 
software

Resource|Wired Memory Used by Kernel  
-|:-:
Process|16 kilobytes
Thread|blocked in a continuation—5 kilobytes; blocked—21 kilobytes
Mach port|116 bytes
Mapping|32 bytes
Library|2 kilobytes plus 200 bytes for each task that uses it
Memory region|160 bytes


> 注意：这些测量值可能随着操作系统的每个新版本而改变。它们在这里提供给你粗略估计系统资源使用的相对成本。

正如您所看到的，每个线程、进程和库都会对系统的驻留空间做出贡献。但是，除了你的应用程序使用 **wired memory** 之外，内核（kernel）本身也需要 **wired memory**，为以下实体：

* VM 对象 - VM objects
* 虚拟内存缓冲区缓存 - the virtual memory buffer cache
* I/O缓冲区缓存 - I/O buffer caches
* 驱动程序 - drivers

**Wired data structures** 还与用于存储虚拟内存映射信息的物理页面和映射表相关联，这两个实体都随着可用物理内存的数量而扩展。 因此，当您向系统添加内存时，即使没有其他更改， **wired memory** 的数量也会增加。 当计算机第一次启动到 Finder 中时，没有其他应用程序在运行，**wired memory** 可能会消耗大约 14 兆字节的 64 兆字节系统和 17 兆字节的 128 兆字节系统。wired memory can consume approximately 14 megabytes of a 64 megabyte system and 17 megabytes of a 128 megabyte system。

**Wired memory pages** 在无效时不会被立即移回空闲列表。相反，当空闲页数低于触发页面输出事件的阈值时，它们会被“垃圾收集（garbage collected）”。
