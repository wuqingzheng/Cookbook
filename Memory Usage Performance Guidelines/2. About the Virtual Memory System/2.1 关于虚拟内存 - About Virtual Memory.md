## 2.1. 关于虚拟内存 - About Virtual Memory

**虚拟内存**允许操作系统摆脱物理 RAM 的限制。虚拟内存管理器为每个进程创建一个逻辑地址空间（或虚拟地址空间），并将其划分为统一大小的称为页面（pages）的内存块。处理器及其内存管理单元（MMU）维护一个页表（page table），以将程序的逻辑地址空间中的页面映射到计算机 RAM 中的硬件地址。当程序的代码访问内存中的地址时，MMU 使用页表将指定的逻辑地址转换为实际的硬件内存地址。此转换自动发生，并对正在运行的应用程序是透明的。

就程序而言，其逻辑地址空间中的地址始终可用。但是，如果应用程序访问当前不在物理 RAM 中的内存页面上的地址，则会发生页面错误。发生这种情况时，虚拟内存系统会立即调用特殊的页面错误处理程序（page-fault handler）来响应错误。页面错误处理程序停止当前正在执行的代码，查找空闲的物理内存页面，从磁盘加载包含所需数据的页面，更新页面表，然后将控制权交给程序的代码，程序的代码就可以正常访问内存地址了。这个过程被称为分页（paging）。

如果物理内存中没有空闲页面，处理程序必须首先释放现存页面才能为新页面腾出空间。系统如何释放页面取决于平台。在 **OS X** 中，虚拟内存系统通常会将页面写入后备存储。后备存储是一个基于磁盘的存储库，其中包含给定进程使用的内存页的副本。将数据从物理内存移动到后台存储称为 **paging out**（或 swapping out）;将数据从后备存储移回物理内存称为 **paging in**（或 swapping in）。在 **iOS** 中，没有后备存储，因此不会将页面 **paged out** 到磁盘，但只读页面仍可根据需要从磁盘 **paged in**。

在 **OS X** 和早期版本的 **iOS** 中，页面大小为 4KB。在较新版本的 **iOS** 中，基于 **A7** 和 **A8** 的系统将 16KB 页面显示给以 4KB 物理页面支持的 64 位用户空间，而 **A9** 系统则将 16KB 物理页面显示给以 16KB 的页面支持的64 位用户空间。这些大小决定了发生页面错误时系统从磁盘读取的 KB 数。当系统花费不成比例的时间 - 处理页面错误和读写页面的时间超过程序执行代码时间时，可能会发生磁盘振荡，。

任何类型的分页，尤其是磁盘振荡（disk thrashing），都会对性能造成负面影响，因为它会迫使系统花费大量时间读取和写入磁盘。从后台存储中读取页面需要大量时间，并且比直接从 RAM 中读取要慢很多。如果系统必须先写入页面才能从磁盘读取其他页面，则性能影响会更糟。
