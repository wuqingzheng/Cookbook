## 2. 密码学概念深入 - Cryptography Concepts In Depth
**Cryptography**（来自希腊语 kryptos，意思是隐藏的）这个词的核心是指使数据无法被窥探的技术。但是，**cryptography** 也可以用于其他目的。**cryptography** 包括一系列技术，可用于验证数据的真实性（检测修改），确定个人或其他实体的身份，确定谁发送了特定消息或创建了特定数据段，通过网络安全地发送信息，将文件安全地锁定在密码或口令后面等等。

本章介绍了许多这些技术，从基本加密开始，然后转向构建于其上的其他加密。

> 注意：本章重复了 [Security Overview](https://developer.apple.com/library/content/documentation/Security/Conceptual/Security_Overview/Introduction/Introduction.html#//apple_ref/doc/uid/TP30000976) 中的许多概念，但具有更多细节和深度。 在阅读本章之前，您可能会发现阅读该文档很有帮助。

### 2.1 什么是加密？ - What Is Encryption?

加密就是将数据转换成一种不使用某些密钥就无法搞清楚的形式。这种变换后的数据被称为密文（ciphertext）。使用密钥来反转此过程并将数据恢复为其原始（明文）形式称为解密。**OS X** 和 **iOS** 中的大多数安全 API 在某种程度上依赖于文本或数据的加密。例如，加密用于创建证书和数字签名，安全存储钥匙串中的秘密以及安全传输信息。

加密可以是将一个字符替换为另一个字符的简单过程 - 在这种情况下，密钥是替代规则 - 可以是复杂的数学算法。为了安全起见，解密密文越困难越好。另一方面，如果算法过于复杂，需要很长时间才能完成，或者需要密钥太大而无法容易存储，那么在个人计算机中使用就变得不切实际了。因此，必须在加密强度（即，某人发现算法和密钥有多困难）和易用性之间达成一定的平衡。

出于实际的目的，加密只需要足够强大以保护数据的时间数据可能对有恶意的人有用的时间。例如，如果您只需要在合同授予后才对合同秘密进行出价，那么可以在几周内破解的加密方法就足够了。如果你正在保护你的信用卡号码，你可能需要一种多年来不能破解的加密方法。


### 2.2 加密类型 - Types of Encryption
在计算机安全中使用两种主要的加密类型，称为**对称密钥加密**和**非对称密钥加密**。加密密切相关的过程称为加密哈希，其中数据通过密钥和不可逆转的数学算法进行转换。本节的其余部分讨论加密密钥，密钥交换机制（包括用于某些安全传输协议的 Diffie-Hellman 密钥交换）以及加密哈希函数。

#### 2.2.1 对称密钥 - Symmetric Keys
对称密钥加密术（也称为秘密密钥加密术）是大多数人所熟悉的密钥的经典使用：使用相同的密钥来加密和解密数据。这个经典的也是最容易破解的版本是凯撒密码（以凯撒大帝的名字命名），其中信件中的每个字母都被一个字母替换，字母在字母表中的位置是固定的（例如 "a" 替换为"c"，"b"替换为"d"等等）。在凯撒密码中，用于加密和解密消息的密钥只是字母旋转的位置数和旋转方向。现代对称密钥算法要复杂得多，而且要难得多。但是，它们共享使用相同密钥进行加密和解密的特性。

对称密钥加密术有许多不同的算法，提供从最小到几乎牢不可破的安全性。其中一些算法提供了强大的安全性，易于在代码中实现，以及快速的加密和解密。这种算法对于加密存储在计算机中的文件以在未经授权的个人使用计算机的情况下保护它们是非常有用的。它们对于从一台计算机向另一台计算机发送消息的用处不大，因为通信通道的两端必须拥有该密钥并且必须保证其安全。这些密钥的分发和安全存储可能很困难，并且可能会导致安全漏洞。

1968 年，美国海军情报部队的普韦布洛号被朝鲜人俘虏。当时，每艘海军舰艇都在各种安全级别上为各种代码机器提供对称密钥。每个密钥每天更换。由于没有办法知道这些钥匙中有多少没有被普韦布洛的船员销毁，以致被朝鲜占有，海军不得不假设普韦布洛所有的钥匙都已经被盗用。太平洋战区内的每个船只和岸上电台（即数千个装置，包括海上的船只）必须通过物理方式携带代码簿和穿孔卡片来更换其每个装置的所有钥匙。

普韦布洛事件是一个极端的例子。然而，它与通过因特网提供商业安全通信的问题有一些共同之处。在这两种情况下，代码都用于发送安全信息 - 不是在两个地点之间，而是在服务器（互联网服务器或海军通信中心）和大量通信者（个人网络用户或船舶和岸上电台）之间发送。参与安全通信的最终用户越多，秘密对称密钥的分发和保护问题就越严重。

尽管用于交换或创建对称密钥的安全技术可以在某种程度上克服这个问题（例如，本章稍后描述的 Diffie-Hellman 密钥交换），但是用于计算机通信的更实际的解决方案来自实用算法的发明用于非对称密钥加密。

#### 2.2.2 不对称密钥 - Asymmetric Keys
在非对称密钥加密中，不同的密钥用于加密和解密消息。非常有用的不对称密钥算法是那些不能从另一个中推导出密钥的密钥算法。在这种情况下，一个密钥可以公开，而另一个可以保密。这种安排通常称为公钥加密技术，与对称加密相比具有明显的优势：消除了将密钥分发给大量用户的必要性，并且该算法可用于身份验证如同密码学。

1977 年，Ron Rivest，Adi Shamir 和 Len Adleman 描述了第一个公开密钥算法，它的名字叫做 RSA 加密。虽然其他公钥算法已经创建，但 RSA 仍然是最常用的。该方法的数学超出了本文的范围，并可在互联网和许多关于密码学的书中找到。该算法基于两个大素数及其乘积的数学运算。据信，其实力与大量因素的困难有关。以现代数字计算机的当前和可预见的速度，在生成 RSA 密钥时选择足够长的素数应该使该算法无限期地保密。但是，这种信念尚未在数学上得到证明，无论是快速分解算法还是完全不同的破解 RSA 加密的方法都是可能的。而且，如果开发出实际的量子计算机，那么分解大数量将不再是棘手的问题。

基于与 RSA 等效的复杂度的不同数学的其他公钥算法包括 ElGamal 加密和椭圆曲线加密。它们的使用与 RSA 加密类似（尽管它们背后的数学不同），并且在本文档中不会进一步讨论它们。

要查看公钥算法如何解决密钥分发问题，请假定 Alice 希望从 Bob 接收安全通信。程序如图 1-1 所示。

Figure 1-1  Asymmetric key encryption

![](https://developer.apple.com/library/content/documentation/Security/Conceptual/cryptoservices/Art/asymmetric_keys_2x.png)

图 1-1 中所示的安全消息交换具有以下步骤：

1. Alice 使用公钥算法之一来生成一对加密密钥：一个她保密的私钥和一个公钥。她还准备发送给 Bob 的消息。
2. Alice 将公钥发送给 Bob，未加密。因为她的私钥不能从公钥中推导出来，所以这样做不会以任何方式危害她的私钥。
3. Alice 现在可以很容易地向 Bob 证明自己的身份（一种称为认证的过程）。为此，她使用她的私钥加密她的消息（或消息的任何部分）并将其发送给 Bob。
4. Bob 用 Alice 的公钥解密该消息。这证明消息必须来自 Alice，因为只有她拥有用于加密它的私钥。
5. Bob 使用 Alice 的公钥将他的消息加密并发送给 Alice。该消息是安全的，因为即使被截取，除 Alice 之外，没有人拥有解密它所需的私钥。
6. Alice 用她的私钥解密消息。

由于加密和认证是国家安全和保护公司机密的重大课题，因此一些非常聪明的人员参与创建安全系统并试图打破这些系统。因此，实际的安全通信和认证程序比刚刚描述的要复杂得多，这应该不令人吃惊。例如，用私钥加密消息的身份验证方法可以通过中间人攻击得到解决，在这种攻击中，有恶意的人（通常在密码学书籍中称为 Eve）拦截 Alice 的原始消息并用自己的替代它，以便 Bob 使用的不是 Alice 的公钥，而是 Eve。 Eve 然后截取 Alice 的每条信息，用 Alice 的公钥解密它，改变它（如果她希望的话），并用她自己的私钥重新加密它。当 Bob 收到消息时，他用 Eve 的公钥解密，认为密钥来自 Alice。

虽然这是一个过于宽泛且技术性很强的主题，但本文档将详细介绍数字证书和数字签名，可以帮助解决这些安全问题。这些技术将在本章后面介绍。

### 2.3 Diffie-Hellman 密钥交换 - Diffie-Hellman Key Exchange
Diffie-Hellman 密钥交换协议是通信会话两端通过不安全信道安全地生成共享对称密钥的一种方式。Diffie-Hellman 通常使用类似于 RSA 公钥加密的数学实现。但是，类似的技术也可以用于椭圆曲线加密。基本步骤如下：

1. Alice 和 Bob 交换公钥。
	- 对于 RSA，这些密钥必须具有相同的模数部分 - p。
	- 对于椭圆曲线加密，必须商定用于加密的域参数。  
	通常，您应该使用 RFC 5114 中指定的模数或域参数值。
2. Alice 和 Bob 使用它们的私钥对共享的非秘密值 g 进行加密，并且它们交换这些加密的值。
g 的值通常也取自 RFC 5114，但是如果在使用 RSA 时选择了另一个值，则 g 的值必须是原始根模 p，即任何不共享除 p 以外的公约数的数，与 g mod p 的幂一致。

3. Alice 用她的私钥加密从 Bob 接收到的加密值，反之亦然。这些值用作共享会话密钥。
此时，即使双方都不知道对方的私钥，双方的会话密钥也是相同的。第三方拦截公钥但不知道任何一个私钥都不能生成会话密钥。因此，使用生成的会话密钥加密的数据在传输过程中是安全的。

尽管 Diffie-Hellman 密钥交换提供了强大的保护，可以防止拦截数据，但它没有提供任何机制来确保连接另一端的实体是您认为的实体。也就是说，这个协议很容易受到中间人攻击。因此，它有时与其他一些认证方法一起使用，以确保数据的完整性。

Apple Filing Protocol（AFP）版本 3.1 和更高版本以及 Apple 的安全传输 API 支持 Diffie-Hellman 密钥交换。由于 RSA 加密往往比对称密钥方法慢，所以当必须交换大量加密数据时，Diffie-Hellman（以及其他公钥用于生成对称私钥的系统）可能会很有用。

### 2.4 加密哈希函数 - Cryptographic Hash Functions
密码散列函数可以获取任意数量的数据并应用算法将其转换为固定大小的输出值。为了使密码散列函数有用，从散列值重建原始数据是非常困难或不可能的，并且极其不可能由任何其他输入数据产生相同的输出值。

有时验证数据的完整性比保密更重要。例如，如果 Alice 向 Bob 发送消息指示他撕碎某些记录（当然是合法的），那么在继续破碎之前，Bob 确认文档列表是否准确是非常重要的。但是，由于粉碎是合法的，因此不需要对消息进行加密，这是一个计算成本高且耗时的过程。相反，Alice 可以计算消息的散列（称为消息摘要）并使用她的私钥对摘要进行加密。当 Bob 收到消息时，他使用 Alice 的公钥对消息摘要进行解密（从而验证消息来自 Alice），并从消息文本计算他自己的消息摘要。如果两个摘要匹配，Bob知道该消息没有被破坏或被篡改。

您将使用的最常用的散列函数是 SHA-1，这是美国政府开发和发布的一种算法，它可以从长达 `2 ** 64` 位的任何数据产生 160 位散列值。还有一些更奇特的算法，如 SHA-2，基于椭圆曲线的算法等等。

为了与现有系统和基础架构兼容，您可能偶尔需要使用较早的算法，例如MD5，但由于已知的弱点，不推荐将它们用于新设计。

### 2.5 数字签名 - Digital Signatures
数字签名是一种使用公钥加密技术确保消息或其他数据完整性的方法。就像纸上用墨水书写的传统签名一样，它们可以用来验证数据签名者的身份。但是，数字签名超越了传统签名，因为它们也可以确保数据本身没有被改变。这就像签署支票一样，如果某人更改了支票上写的金额，支票正面就会显示“无效”的标记。

在签名人可以创建数字签名之前，签名人必须先拥有数字身份 - 一个公私钥对和一个证明签名人公钥的真实性的相应数字证书。

签名者生成数据的消息摘要，然后使用私钥加密摘要。签名者包含加密摘要以及有关签名者数字证书和消息的信息。加密摘要和数字证书的组合是数字签名。

证书可以稍后由收件人用来验证签名;该证书包括解密摘要所需的公钥和用于创建摘要的算法。要验证签名文档未被更改，收件人使用相同的算法创建收到的邮件的摘要，然后使用公钥从邮件签名中解密加密的摘要。如果两个摘要是相同的，则该消息不能被改变，并且必须已经由公钥的所有者发送。

为确保提供签名的人不仅是提供数据的同一人，而且也是他或她自称的人，证书还由签发证书的证书颁发机构签署。 （稍后更多关于认证机构。）

数字签名在代码签名中起着关键作用。鼓励开发者签署他们的应用程序。执行时，检查每个应用程序的签名是否有效。 iOS上的所有应用都需要数字签名。阅读代码签名指南了解如何使用 **OS X** 和 **iOS** 代码签名的详细信息。

图 1-2 说明了数字签名的创建。

Figure 1-2  Creating a digital signature

![](https://developer.apple.com/library/content/documentation/Security/Conceptual/cryptoservices/Art/signed_doc_2x.png)

图 1-3 说明了数字签名的验证。收件人从签名者的证书中获取签名者的公钥并使用它来解密摘要。 然后，使用证书中指定的算法，收件人创建数据的新摘要，并将新摘要与签名中传递的摘要的解密副本进行比较。 如果它们匹配，则接收的数据必须与签名者创建的原始数据相同。

Figure 1-3  Verifying a digital signature

![](https://developer.apple.com/library/content/documentation/Security/Conceptual/cryptoservices/Art/verify_signature_2x.png)

### 2.6 Digital Certificates - 数字证书

数字证书（digital certificate）是用于验证持证人或证书发送人身份的数据集合。

例如，X.509 证书包含以下信息：

- 结构信息版本，序列号，用于创建签名的消息摘要算法等等
- 来自证书颁发机构（CA）的数字签名 - 发布证书的个人或组织 - 确保证书未被更改并指明发行人的身份
- 有关证书持有者名称，电子邮件地址，公司名称，所有者的公钥等的信息
- 有效期（证书在此期间之前或之后无效）
- 证书扩展 - 包含附加信息的属性，例如此证书的允许使用

细心的读者会注意到，数字签名包括签名者的证书，而签名者的证书又包含包含另一证书的数字签名。

通常，每个证书通过使用另一个证书进行验证，创建一个信任链 - 一个证书链，每个证书都由链中的下一个证书进行数字签名，并以一个根证书结束。此根证书的所有者称为根证书颁发机构。图 1-4 说明了数字证书的各个部分。

Figure 1-4  Anatomy of a digital certificate

![](https://developer.apple.com/library/content/documentation/Security/Conceptual/cryptoservices/Art/certificate_anatomy_2x.png)

根证书是自签名的（self-signed），这意味着根证书的签名是由根证书颁发机构自己创建的。图 1-5 和图 1-6 说明了如何创建和使用证书链。图 1-5 显示了根证书颁发机构如何创建自己的证书，然后为辅助证书颁发机构创建证书。

图 1-5 为根 CA 和备用 CA 创建证书

![](https://developer.apple.com/library/content/documentation/Security/Conceptual/cryptoservices/Art/keys_in_cert_chain_2x.png)

图 1-6 显示了辅助证书颁发机构如何为最终用户创建证书以及最终用户如何使用它来签署文档。

图 1-6 为最终用户创建证书并使用它签署文档

![](https://developer.apple.com/library/content/documentation/Security/Conceptual/cryptoservices/Art/keys_in_cert_chain2_2x.png)

在图 1-6 中，文档的创建者已经对文​​档进行了签名。签名表示文档创建者的证书（在图中标记为“用户”）。文档的创建者使用私钥签署文档，并且签名证书包含相应的公钥，该公钥可用于解密消息摘要以验证签名（先前在数字签名中进行了描述）。此证书连同私钥和公钥由证书颁发机构（CA）提供。

为了验证用户证书的有效性，使用 CA 的证书对证书进行签名。CA 的证书包括解密用户证书的消息摘要所需的公钥。继续证书链，CA 的证书使用颁发该证书的机构的证书进行签名。该链可以通过任意数量的中间证书继续进行，但在图 1-5 中，CA证书的颁发者是根证书颁发机构。请注意，根 CA 的证书与其他证书不同，是自签名的，即它不引用其他证书颁发机构，而是使用根 CA 自己的私钥进行签名。

当 CA 创建证书时，它使用其私钥来加密证书的消息摘要。CA 颁发的每个证书的签名都是指其自己的签名证书。CA 的公钥位于此证书中，验证签名的应用程序必须提取此密钥以验证 CA 的证书。因此，它在证书链中继续到根CA的证书。当根 CA 颁发证书时，它也会签署证书。但是，此签名证书不是由另一个 CA 颁发的;链子在这里停止。相反，根 CA 会颁发自己的签名证书，如图 1-5 所示。

根 CA 的证书可以通过创建摘要并将其与广泛可用的证书进行比较来验证。通常，根证书和根CA的公钥已存储在应用程序或需要验证签名的计算机上。

可以使用不是根证书的可信证书来结束证书链。例如，证书可以被认证为用户信任的证书，或者可以被交叉认证 - 即用多于一个证书链签名。证书信任的其他证书（包括根证书和其他证书）的通用术语是锚定证书。由于大多数锚定证书都是根证书，因此这两个术语经常互换使用。

您对给定证书的信心取决于您对主播证书的信心;例如，您在证书颁发机构和他们的过程中拥有的信任，以确保证书链中的后续证书收件人完全通过身份验证。出于这个原因，检查数字签名附带的证书总是一个好主意，即使签名看起来是有效的。在 **OS X** 和 **iOS** 中，您收到的所有证书都存储在您的钥匙串中。在 OS X 中，您可以使用钥匙串访问实用程序来查看它们。

数字证书的某些属性（称为证书扩展名）提供了有关证书的附加信息。其中一些扩展描述了证书是如何使用的。例如，证书扩展可能指示密钥可用于代码签名，或者可能提供 TLS 证书有效的其他域名的列表。其他扩展提供签名的时间戳，指明证书何时用于签名特定文档，从而允许您验证现在到期的证书在用于签署文档时是否有效。还有一些提供用于检查证书是否被撤销的信息。等等。

这些证书扩展是在信任策略的上下文中解释的 - 一组规则指定特定扩展如何影响证书是否应该为给定用途信任。例如，信任策略可能会指定为了被信任来验证数字签名的电子邮件，证书必须包含与电子邮件发件人的地址相匹配的电子邮件地址。