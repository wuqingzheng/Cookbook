## 2. 定时器（Timer）

定时器与 **NSRunLoop** 对象一起工作。因此，它们不提供实时机制（定时器的精度是有限的）。如果您只是想在将来某个确定时间发送消息，则不可以使用定时器。

### 2.1 定时器和 RunLoops（Timers and RunLoops）

定时器由 **NSTimer** 对象表示，他们与 **NSRunLoop** 对象一起工作。 **NSRunLoop** 对象控制等待输入的循环，并且它们使用定时器来帮助确定它们应该等待的最长时间。当计时器的达到时间限制时，**run loop** 触发计时器（使其消息被发送），然后检查新的输入。

注册计时器的运行循环模式（run loop mode ）必须是在运行状态才能触发计时器。对于使用 **Application Kit** 或 **UIKit** 构建的应用程序，应用程序对象为您运行主线程的 **run loop**。但是，在辅助线程中，您必须自己运行 **run loop**， 请参阅 **run loop** 以了解详细信息。

每个运行循环计时器（run loop timer）一次只能在一个 **run loop** 中注册，但它可以添加到该 **run loop** 中的多个运行循环模式（run loop mode ）中。

### 2.2 定时精度（Timing Accuracy）

计时器不是一个实时机制。只有某个添加了定时器的运行循环模式在运行状态并且能够检查定时器的触发时间是否已过去，它才会触发。由于 **run loop** 通常管理各种输入源，所以定时器的时间间隔的有效分辨率被限制在 **50-100** 毫秒的量级上。如果定时器的触发时间在 **run loop** 处于定时器未监视的模式或长时间调用（long callout）期间到达，则定时器将在下次 **run loop** 检查定时器时才触发。因此，计时器触发的实际时间可能是计划的触发时间之后的相当长的一段时间。

重复计时器（repeating timer）会根据预定的触发时间重新安排自己，而不是实际的触发时间。例如，如果定时器计划在特定时间以及之后每隔 **5** 秒触发一次，那么即使实际触发时间延迟，预定的触发时间将始终落在原来的 **5** 秒钟的时间间隔上。如果触发时间延迟至其超过一个或多个预定触发时间，则在该时间段内定时器仅被触发一次;计时器在触发后将被重新安排在未来的下一个预定触发时间。

### 2.3 计时器的替代品（Alternatives to Timers）

如果您只是想在将来某个时候发送消息，则可以不使用定时器。您可以直接在另一个对象上调用方法 `performSelector：withObject：afterDelay：`及其相关方法。 某些变体（`performSelectorOnMainThread：withObject：waitUntilDone：`）允许您在特定线程上调用该方法。您还可以使用 `cancelPreviousPerformRequestsWithTarget:` 及其相关方法取消延迟消息。
