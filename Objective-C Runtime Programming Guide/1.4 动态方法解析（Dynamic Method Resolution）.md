## 1.4 动态方法解析（Dynamic Method Resolution）
> 本章介绍如何动态地提供方法的实现。

### 1.4.1 Dynamic Method Resolution
在某些情况下，您可能想动态地提供方法的实现。 例如，Objective-C声明的属性功能（请参阅Objective-C编程语言中的声明属性）包含@dynamic指令：

```@dynamic propertyName;```

它告诉编译器与该属性关联的方法将被动态地提供。

您可以实现 `resolveInstanceMethod：`和 `resolveClassMethod方法：` 分别为实例和类方法的给定选择器动态提供实现。

`Objective-C` 方法实际上只是一个至少需要两个参数 `self` 和 `_cmd` 的**C**函数。 您可以使用函数 `class_addMethod` 将函数作为方法添加到类中。 因此，给出以下功能：

``` Objective-C
void dynamicMethodIMP(id self, SEL _cmd) {
// implementation ....
}
```

我们可以使用 `resolveInstanceMethod` 将其动态添加到类中作为方法（称为 `resolveThisMethodDynamically`）：像这样：

``` Objective-C
@implementation MyClass
+ (BOOL)resolveInstanceMethod:(SEL)aSEL
{
if (aSEL == @selector(resolveThisMethodDynamically)) {
class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, "v@:");
return YES;
}
return [super resolveInstanceMethod:aSEL];
}
@end
```

**消息转发**和**动态方法解析**在很大程度上是正交的。 一个类有机会在消息转发机制启动之前动态地解析一个方法。如果调用 `respondsToSelector：`或 `instancesRespondToSelector：`，动态方法解析器有机会首先为选择器提供一个 **IMP**。 如果您实现 `resolveInstanceMethod：` 但希望特定的选择器通过转发机制实际转发，则您将为这些选择器返回NO。

### 1.4.2 Dynamic Loading

`Objective-C`程序可以在运行时加载和链接新的类和类别。 新代码被合并到程序中，并且和在开始时加载的类和类别的处理方式相同。

动态加载可以用来做很多不同的事情。 例如，系统偏好设置应用程序中的各个模块都是动态加载的。

在Cocoa环境中，动态加载通常用于允许应用程序进行自定义。其他人可以编写程序在运行时加载的模块 - 就像Interface Builder加载自定义调色板一样，OS X系统偏好设置应用程序加载自定义首选项模块。可加载模块扩展了您的应用程序可以执行的操作。他们以您允许的方式为其作出贡献，但无法预期或定义您自己。您提供了框架，但其他人提供了代码。

尽管在Mach-O文件（objc_loadModules，在objc / objc-load.h中定义）中执行动态加载Objective-C模块的运行时函数，但Cocoa的NSBundle类为动态加载提供了更方便的接口 - 一个是对象面向并与相关服务相结合。有关NSBundle类及其用法的信息，请参阅Foundation框架参考中的NSBundle类规范。有关Mach-O文件的信息，请参阅OS X ABI Mach-O文件格式参考。
