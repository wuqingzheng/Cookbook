## 3. 操作队列 - Operation Queues
**Cocoa** 操作（operations）是以一种面向对象的方式来封装你希望异步执行的工作。 操作旨在与操作队列一起使用，或者单独使用。 因为它们基于 **Objective-C**，所以在 **OS X** 和 **iOS** 中基于 **Cocoa** 的应用程序中最常使用操作。

本章将向您介绍如何定义和使用操作。

### 3.1 关于操作对象 - About Operation Objects
**操作对象** 是 NSOperation 类（在 Foundation 框架中）的一个实例，用于封装希望应用程序执行的工作。 NSOperation 类本身是一个抽象基类，为了做任何有用的工作，它必须被分类。 尽管是抽象的，但这个类确实提供了大量的基础设施，以尽量减少您在它自己的子类中所要完成的工作量。另外，Foundation 框架提供了两个具体的子类，您可以使用原有的代码。 表2-1 列出了这些类以及您如何使用每个类的摘要。

Table 2-1  Operation classes of the Foundation framework

Class|Description
-|:-:
NSInvocationOperation|A class you use as-is to create an operation object based on an object and selector from your application. You can use this class in cases where you have an existing method that already performs the needed task. Because it does not require subclassing, you can also use this class to create operation objects in a more dynamic fashion.<br>For information about how to use this class, see Creating an NSInvocationOperation Object.
NSBlockOperation|A class you use as-is to execute one or more block objects concurrently. Because it can execute more than one block, a block operation object operates using a group semantic; only when all of the associated blocks have finished executing is the operation itself considered finished.<br>For information about how to use this class, see Creating an NSBlockOperation Object. This class is available in OS X v10.6 and later. For more information about blocks, see Blocks Programming Topics.
NSOperation|The base class for defining custom operation objects. Subclassing NSOperation gives you complete control over the implementation of your own operations, including the ability to alter the default way in which your operation executes and reports its status.
For information about how to define custom operation objects, see Defining a Custom Operation Object.

所有操作对象都支持以下主要功能：

* 支持在操作对象之间建立基于图形（graph-based）的依赖关系。这些依赖关系会阻止给定的操作运行，直到它所依赖的所有操作都已完成运行。有关如何配置依赖关系的信息，请参阅[Configuring Interoperation Dependencies](https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW17)。
* 支持可选的完成块，该块在操作的主任务完成后执行。（仅限 OS X v10.6 及更高版本。）有关如何设置完成块的信息，请参阅[Setting Up a Completion Block](https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW33)。
* 支持使用 KVO 通知监视对操作执行状态的更改。有关如何观察 KVO 通知的信息，请参阅[Key-Value Observing Programming Guide](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i)。
* 支持对操作进行优先级排序，从而影响其相对执行顺序。有关更多信息，请参阅 [Changing an Operation’s Execution Priority](https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW31)。
* 支持取消语义，允许您在执行时暂停操作。有关如何取消操作的信息，请参阅 [Canceling Operations](https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW39)。有关如何在自己的操作中支持取消的信息，请参阅[ Responding to Cancellation Events](https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW24)。

操作旨在帮助您提高应用程序中的并发水平。操作也是将应用程序行为组织和封装为简单离散块的好方法。您可以将一个或多个操作对象提交给一个队列，并让相应的工作在一个或多个单独的线程上异步执行，而不是在应用程序的主线程上运行一些代码。


### 3.2 并发与非并发操作 - Concurrent Versus Non-concurrent Operations
虽然通常通过将操作添加到操作队列来执行操作，但这不是必需的。也可以通过调用它的 `start` 方法手动执行一个操作对象，但这样做并不能保证该操作与其他代码同时运行。 NSOperation 类的 `isConcurrent` 方法告诉您一个操作是相对于调用 `start` 方法的线程同步或异步运行的。默认情况下，此方法返回NO，这意味着该操作在调用线程中同步运行。

如果你想实现一个并发操作 - 也就是说，相对于调用线程异步运行的操作 - 你必须编写额外的代码来异步启动操作。例如，您可能会产生一个单独的线程，调用异步系统函数或执行其他任何操作，以确保start方法启动任务并立即返回，并且很可能在任务完成之前返回。

大多数开发人员不应该需要实现并发操作对象。如果您始终将操作添加到操作队列中，则不需要实施并发操作。当您向操作队列提交非并发操作时，队列本身会创建一个线程来运行您的操作。因此，向操作队列添加非并发操作仍然会导致异步执行操作对象代码。只有在需要异步执行操作而不将其添加到操作队列的情况下，才需要定义并发操作的能力。

有关如何创建并发操作的信息，请参阅 [Configuring Operations for Concurrent Execution]() 和 [NSOperation Class Reference]()。


### 3.3 创建一个 NSInvocationOperation 对象 - Creating an NSInvocationOperation Object

**NSInvocationOperation** 类是 **NSOperation** 的一个具体子类，它在运行时会调用您在指定的对象上指定的选择器。使用此类可以避免为应用程序中的每个任务定义大量自定义操作对象;特别是如果您要修改现有的应用程序并且已经拥有执行必要任务所需的对象和方法。当你想要调用的方法可以根据具体情况而改变时，你也可以使用它。例如，您可以使用调用操作来执行基于用户输入动态选择的选择器。

创建 **invocation operation** 的过程非常简单。您可以创建并初始化类的新实例，将所需的对象和选择器传递给初始化方法。清单 2-1 显示了自定义类中的两个方法，用于演示创建过程。 `taskWithData：` 方法创建一个新的调用对象并为其提供另一个方法的名称，该方法包含任务实现。

Listing 2-1  Creating an NSInvocationOperation object

```
@implementation MyCustomClass
- (NSOperation*)taskWithData:(id)data {
    NSInvocationOperation* theOp = [[NSInvocationOperation alloc] initWithTarget:self
                    selector:@selector(myTaskMethod:) object:data];
 
   return theOp;
}
 
// This is the method that does the actual work of the task.
- (void)myTaskMethod:(id)data {
    // Perform the task.
}
@end

```

### 3.4 创建一个 NSBlockOperation 对象 - Creating an NSBlockOperation Object

**NSBlockOperation** 类是 **NSOperation** 的一个具体子类，充当一个或多个 **block** 对象的包装。此类为已经使用操作队列并且不想创建调度队列的应用程序提供面向对象的包装器。您还可以使用 **block operations** 来利用操作依赖关系（operation dependencies）、**KVO** 通知以及可能不适用于分派队列（dispatch queues）的其他功能。

在创建块操作（block operation）时，通常在初始化时至少添加一个块;您可以稍后根据需要添加更多块。当需要执行 **NSBlockOperation** 对象时，对象将其所有块提交给默认优先级并发调度队列。该对象然后等待，直到所有块完成执行。当最后一个块完成执行时，操作对象将自己标记为已完成。因此，您可以使用块操作来跟踪一组正在执行的块，就像使用线程连接来合并多线程的结果一样。区别在于，因为块操作本身在单独的线程上运行，所以应用程序的其他线程可以在等待块操作完成的同时继续工作。

清单 2-2 显示了如何创建一个 **NSBlockOperation** 对象的简单示例。该块本身没有参数并且没有显着的返回结果。

Listing 2-2  Creating an NSBlockOperation object

```
NSBlockOperation* theOp = [NSBlockOperation blockOperationWithBlock: ^{
      NSLog(@"Beginning operation.\n");
      // Do some work.
   }];
```

创建块操作对象后，可以使用 `addExecutionBlock：` 方法向其添加更多块。如果需要连续执行块，则必须将它们直接提交到所需的调度队列。