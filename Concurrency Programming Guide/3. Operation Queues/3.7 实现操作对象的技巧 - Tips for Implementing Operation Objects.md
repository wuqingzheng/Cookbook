## 3.7 实现操作对象的技巧 - Tips for Implementing Operation Objects
虽然操作对象很容易实现，但在编写代码时应注意一些事情。以下部分描述了在为操作对象编写代码时应考虑的因素。

### 3.7.1 管理操作对象中的内存 - Managing Memory in Operation Objects
以下部分描述操作对象中良好内存管理的关键元素。 有关 Objective-C 程序内存管理的一般信息，请参见 [Advanced Memory Management Programming Guide](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i)。

#### 避免每线程存储 - Avoid Per-Thread Storage
尽管大多数操作在一个线程上执行，但在非并发操作的情况下，该线程通常由操作队列提供。如果操作队列为您提供线程，则应该将该线程视为由队列拥有并且不会被您的操作触及。具体而言，您不应该将任何数据与您未创建或管理的线程关联。由操作队列管理的线程根据系统和您的应用程序的需要来来去去。因此，在使用每个线程存储的操作之间传递数据是不可靠的，并且可能会失败。

对于操作对象，在任何情况下都不应该使用每线程存储。初始化操作对象时，应该为对象提供执行其工作所需的所有内容。因此，操作对象本身提供了您所需的上下文存储。所有传入和传出的数据都应存储在那里，直到它可以集成到应用程序中或不再需要。

#### 根据需要保持对操作对象的引用 - Keep References to Your Operation Object As Needed
仅仅因为操作对象异步运行，你不应该假设你可以创建它们并忘记它们。 它们仍然只是对象，并且由您来管理代码所需的任何对它们的引用。 如果您需要在操作完成后从操作中检索结果数据，这一点尤其重要。

你应该始终保持自己对操作的引用的原因是，你可能没有机会在稍后询问对象的队列。 队列尽可能快地派遣和执行操作。 在很多情况下，队列在添加后几乎立即开始执行操作。 当您自己的代码返回到队列以获取对该操作的引用时，该操作可能已经完成并从队列中移除。

### 3.7.2 处理错误和异常 - Handling Errors and Exceptions
由于操作本质上是应用程序内的离散实体，因此它们自己负责处理产生的任何错误或异常。在 **OS X v10.6** 及更高版本中，NSOperation 类提供的默认 `start ` 方法不会捕获异常。（在 **OS X v10.5** 中，`start` 方法确实会捕获并抑制异常。）您自己的代码应该始终直接捕获并抑制异常。 它还应该检查错误代码并根据需要通知应用程序的相应部分。如果你替换 `start` 方法，你必须类似地捕获自定义实现中的任何异常，以防止它们离开底层线程的范围。

您应该准备处理的错误情况类型包括以下几种：

- 检查并处理 UNIX 的 `errno-style` 错误代码。
- 检查方法和函数返回的显式错误代码。
- 捕获您自己的代码或其他系统框架抛出的异常。
- 捕获 NSOperation 类自身抛出的异常，这会在以下情况下抛出异常：
	- 当操作未准备好执行但调用其 `start` 方法时
	- 当操作正在执行或已完成（可能是因为它已被取消），并且其 `start` 方法再次被调用
	- 当您尝试将 completion block 添加到正在执行或已完成的操作时
	- 当您尝试检索已取消的 NSInvocationOperation 对象的结果时

如果您的自定义代码确实遇到异常或错误，您应该采取任何必要的步骤将错误传递到您的应用程序的其余部分。 NSOperation 类不提供显式方法来将错误结果代码或异常传递给应用程序的其他部分。因此，如果这些信息对您的应用程序很重要，您必须提供必要的代码。